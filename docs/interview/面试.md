
## 原生 ajax 实现

1. 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象.
2. 创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息.
3. 设置响应 HTTP 请求状态变化的函数.
4. 发送 HTTP 请求.
5. 获取异步调用返回的数据.

在 AJAX 实际运行当中，对于访问 XMLHttpRequest（XHR）时并不是一次完成的，而是分别经历了多种状态后取得的结果，对于这种状态在 AJAX 中共有 5 种，分别是：
0 - (未初始化)还没有调用 send()方法
1 - (载入)已调用 send()方法，正在发送请求
2 - (载入完成)send()方法执行完成，
3 - (交互)正在解析响应内容
4 - (完成)响应内容解析完成，可以在客户端调用了
对于上面的状态，其中“0”状态是在定义后自动具有的状态值，而对于成功访问的状态（得到信息）我们大多数采用“4”进行判断。

```js
var Ajax = {
    get: function(url, fn) {
        // XMLHttpRequest对象用于在后台与服务器交换数据
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function() {
            // readyState == 4说明请求已完成
            if ((xhr.readyState == 4 && xhr.status == 200) || xhr.status == 304) {
                // 从服务器获得数据
                fn.call(this, xhr.responseText);
            }
        };
        xhr.send();
    },
    // datat应为'a=a1&b=b1'这种字符串格式，在jq里如果data为对象会自动将对象转成这种字符串格式
    post: function(url, data, fn) {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', url, true);
        // 添加http头，发送信息至服务器时内容编码类型
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4 && (xhr.status == 200 || xhr.status == 304)) {
                fn.call(this, xhr.responseText);
            }
        };
        xhr.send(data);
    }
};
```

## 原生 jsonp

```js
function jsonp(obj) {
    //定义一个处理Jsonp返回数据的回调函数
    let name = `callback` + Math.floor(Math.random() * 10000);
    window[name] = function(object) {
        obj.success(JSON.parse(object));
    };
    var script = document.createElement('script');
    //组合请求URL
    script.src = obj.url + `?callback=${name}`;
    for (key in obj.data) {
        script.src += '&' + key + '=' + obj.data[key];
    }

    script.onload = function(e) {
        e.currentTarget.remove();
        delete window[name];
    };
    script.onerror = function(e) {
        e.currentTarget.remove();
        delete window[name];
    };
    //将创建的新节点添加到BOM树上
    document.body.appendChild(script);
}

jsonp({
    url: 'http://localhost:8080/test',
    data: {
        name: '小明'
    },
    success: function(obj) {
        alert('性别' + obj.sex);
    }
});
```

## 原型

Object.prototype 位于最顶层

Function.prototype：

```js
Function.prototype.__proto__ === Object.prototype;
```

Function：

```js
Function.__proto__ === Function.prototype;
```

Object:

```js
Object.__proto__ === Function.prototype;
```

Array:

```js
Array.__proto__ === Function.prototype;

Array.prototype.__proto__ === Object.prototype;
```

```js
function A() {}
var a = new A();

A.__proto__ === Function.prototype;

a._proto_ === A.prototype;
A.prototype._proto_ === Object.prototype;
```

## Map Set WeakMap WeakSet

### 集合（Set）

ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。

Set 本身是一种构造函数，用来生成 Set 数据结构。

Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。

Set 是使用键对来存储的。

性能分析：

因为使用键对，所以查找和删除时，不需要遍历。

数组的查找需要遍历，删除(splice(index, 1))需要移动 index 后面元素位置。

对于新添加元素，Set 需要检查重复，数组(push)不需要。

1. Set 查找和删除都比数组块。
2. Set 添加比数组慢。

```js
let set = new Set([1, 2, 3, 3]);
```

操作方法：

-   add(value)：新增，相当于 array 里的 push。
-   delete(value)：存在即删除集合中 value。
-   has(value)：判断集合中是否存在 value。
-   clear()：清空集合。

便利方法：遍历方法（遍历顺序为插入顺序）

-   keys()：返回一个包含集合中所有键的迭代器。
-   values()：返回一个包含集合中所有值得迭代器。
-   entries()：返回一个包含 Set 对象中所有元素得键值对迭代器。
-   forEach(callbackFn, thisArg)：用于对集合成员执行 callbackFn 操作，如果提供了 thisArg 参数，回调中的 this 会是这个参数，没有返回值。
-   for...of

WeakSet 对象允许你将弱引用对象储存在一个集合中。

WeakSet 与 Set 的区别：

-   WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以。
-   WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素。

方法：

-   add(value)：在 WeakSet 对象中添加一个元素 value。
-   has(value)：判断 WeakSet 对象中是否包含 value。
-   delete(value)：删除元素 value。

### 字典（Map）

是一组键值对的结构，具有极快的查找速度。

key 为任何类型的唯一值。

性能分析：

Map 的实现使用了 hash table。

1. Map 添加、查询速度都是高于 Object。
2. Map 删除和 Object 差不多。

其添加查询

```js
const m = new Map([[(a: 1)], [(b: 2)]]);
const o = { p: 'haha' };
m.set(o, 'content');
```

操作方法：

-   set(key, value)：向字典中添加新元素。
-   get(key)：通过键查找特定的数值并返回。
-   has(key)：判断字典中是否存在键 key。
-   delete(key)：通过键 key 从字典中移除对应的数据。
-   clear()：将这个字典中的所有元素删除。

遍历方法：

-   Keys()：将字典中包含的所有键名以迭代器形式返回。
-   values()：将字典中包含的所有数值以迭代器形式返回。
-   entries()：返回所有成员的迭代器。
-   forEach()：遍历字典的所有成员。
-   for...of

~~Map api 共用了两个数组（一个存放 key,一个存放 value）。给 Map set 值时会同时将 key 和 value 添加到这两个数组的末尾。从而使得 key 和 value 的索引在两个数组中相对应。当从 Map 取值时，需要遍历所有的 key，然后使用索引从存储值的数组中检索出相应的 value。这个实现的缺点很大，首先是赋值和搜索的时间复杂度为 O(n)~~；其次是可能导致内存溢出，因为数组会一直保存每个键值引用，即便是引用早已离开作用域，垃圾回收器也无法回收这些内存。

WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。

注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。

WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的 key 则变成无效的），所以，WeakMap 的 key 是不可枚举的。

方法：

-   has(key)：判断是否有 key 关联对象。
-   get(key)：返回 key 关联对象（没有则则返回 undefined）。
-   set(key, value)：设置一组 key 关联对象。
-   delete(key)：移除 key 的关联对象。

### WeakMap 怎么做到弱引用

WeakMap 本质上没有使用任何东西去存储 key 和 value。它只是在 key 上设置了一个属性，其值为 value。获取也是从 key 上读取这个 value。这也是为什么 key 必须为对象的原因。

## 运算符优先级

[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

1. ()括号
2. .成员访问 ()函数调用 new
3. `...++ ...--`
4. ! ~ +.. -.. ++... --... typeof
5. `**`
6. `*` / %
7. `+` -
8. `>=` <= > <
9. == !==
10. & ^ | 位运算符
11. && || 逻辑运算符
12. a ? x : y 条件运算符
13. = op = 运算赋值

```js
let a = { n: 1 };
let b = a;
a.x = a = { n: 2 };
console.log(a.x);
console.log(b);

// undefined
// { n : 2}
```

对象存储在堆中，a、b 只是存储对象在堆中的地址。

先执行 a.x，在原对象中查找属性。

a 赋值为新对象，再将新对象赋值给原对象的 x 属性。

b 指向原对象。

```js
var val = 'smtg';
console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');

// Something
```

`+` 比三元运算有更高的优先级。

### new 符号优先级

new (带参数列表) 优先级 和 `.`、函数调用优先级一致，遵循从左到右

new (无参数列表) 优先级次于上面的，遵循从右到左

```js
function Foo() {
    this.name = 1;
}

Foo.getName = function() {
    alert(3);
};
```

new Foo 和 new Foo()一致。
new Foo.name 根据优先级，会先执行 Foo.name，所以会报错。
new Foo.getName()，先执行 Foo.getName 得到一个函数，假设为 x，再执行 new x()。
new new Foo().getName()，同上，先执行 new Foo()，再执行.getName 获取到一个函数 x，再执行 new x()。

### typeof 和 `!`

```js
const name = 'TianTianUp';
console.log(!typeof name === 'string');
```

typeof 和 `!` 同优先级，从右到左，执行！typeof name 返回 false，再严格相等判断。


## 算法

### 洗牌算法

随机一张牌，与最后一张牌交换。再随机 0 ～倒数第二张牌 之间的一张牌与倒数第二张牌交换。

### 数组 n 数之和等于一个 sum

### 排序

```js
function bubble(array, desc = false) {
    if (!Array.isArray(array)) {
        throw new Error('argument(s) error');
    }

    for (let i = array.length - 1; i >= 0; i--) {
        // 数组最后一项为已经排好的数
        for (let j = 0; j < i; j++) {
            if (desc) {
                if (array[j] < array[j + 1]) {
                    [array[j], array[j + 1]] = [array[j + 1], array[j]];
                }
            } else {
                if (array[j] > array[j + 1]) {
                    [array[j], array[j + 1]] = [array[j + 1], array[j]];
                }
            }
        }
    }
    return array;
}

function insertSort(array, desc = false) {
    if (!Array.isArray(array)) {
        throw new Error('argument(s) error');
    }

    for (let i = 1; i < array.length; i++) {
        const current = array[i];
        let index = 0;

        for (let j = i - 1; j >= 0; j--) {
            if ((!desc && current < array[j]) || (desc && current > array[j])) {
                array[j + 1] = array[j];
            } else {
                index = j + 1;
                break;
            }
        }

        array[index] = current;
    }
    return array;
}

function selectSort(array, desc = false) {
    if (!Array.isArray(array)) {
        throw new Error('argument(s) error');
    }

    for (let i = 0; i < array.length - 1; i++) {
        let index = i;

        for (let j = i + 1; j < array.length; j++) {
            if ((!desc && array[j] < array[index]) || (desc && array[j] > array[index])) {
                index = j;
            }
        }

        [array[i], array[index]] = [array[index], array[i]];
    }

    return array;
}
```

### 二分查找

```js
function binarySearch(array, value, sorted = false) {
    if (!Array.isArray(array)) {
        throw new Error('argument(s) error');
    }

    if (!sorted) {
        array.sort((a, b) => a - b);
    }

    let start = 0;
    let end = array.length - 1;

    while (start <= end) {
        // 中间索引
        const middle = Math.floor((end + start) / 2);

        if (value < array[middle]) {
            end = middle - 1;
        } else if (value > array[middle]) {
            start = middle + 1;
        } else {
            return middle;
        }
    }

    return -1;
}
```

### 判断回文字符串

```js
function palindromeStr(str) {
    const middle = Math.floor((str.length - 1) / 2);

    for (let i = 0; i <= middle; i++) {
        const start = i;
        const end = str.length - 1 - i;

        if (start === end) {
            break;
        }

        if (str[start] !== str[end]) {
            return false;
        }
    }

    return true;
}
```

### 随机定长字符

```js
function randomStr(length = 10) {
    const array = [];
    const asciiStart = 33;
    const asciiEnd = 126;

    for (let i = 0; i < length; i++) {
        array[i] = Math.floor(Math.random() * (asciiEnd - asciiStart + 1) + asciiStart);
    }

    return String.fromCharCode(...array);
}
```

### 全排列算法

#### 交换回溯法

例如：abc -> abc,acb,bac,bca,cab 和 cba。就是所学的排列，第一次从 3 个选取 1 个，第二次从 2 个选取 1 个，总排列种数：`3*2=6`。

算法描述：

循环遍历，先选取第一个不同位，再将剩下的（除第一位）的字符串再循环遍历，选取第二个不同位，继续同上至最后一个元素。递归思想。

例如 abc，选取第一位 abc 三个中的一个，假如是 a，再从 bc 中选取一个假如是 c，所得排列就是 acb。

如何选取：

循环遍历时，每次将第一位与其他位交换。如果出现重复就跳过重复的字符。

例如 abc，遍历到 0 索引时，选取的第一位就是 a，遍历到 1 索引时，将索引 0 的字符和索引 1 的字符交换，即：a 和 b 交换，选取到第一位就是 b。

需要注意的是每次交换后，需要再交换回去，不然排列出错。

```js
/**
 *
 * @param {Array|String} str 带排列的字符串或者数组
 * @param {Number} [str.length] 从中选取多少项排列
 */

function permutation(str, n = str.length) {
    const array = Array.isArray(str) ? str : str.split('');

    if (array.length === 0) {
        return [];
    }

    const res = [];
    const length = n;

    function select(array, start, end, n) {
        if (n < 1) {
            res.push(array.slice(0, length).join(''));
            return '';
        }

        const selected = {};

        for (let i = start; i < end; i++) {
            // 去除重复的选择
            if (selected[array[i]]) {
                continue;
            }
            selected[array[i]] = 1;
            [array[start], array[i]] = [array[i], array[start]];
            select(array, start + 1, end, n - 1);
            [array[start], array[i]] = [array[i], array[start]];
        }
    }
    select(array, 0, array.length, n);
    return res;
}

console.log(permutation('aabc'));
console.log(permutation('aabc', 2));
```

#### 字典序法

1. 从排列的右端开始，找出第一个比右边数字小的数字的序号 j（j 从左端开始计算），即 `j = max{i|pi<pi+1}`
2. 在 pj 的右边的数字中，找出所有比 pj 大的数中最小的数字 pk，即 `k = max{i|pi>pj}`（右边的数从右至左是递增的，因此 k 是所有大于 pj 的数字中序号最大者）
3. 对换 pi，pk
4. 再将 pj+1......pk-1pkpk+1......pn 倒转得到排列 p'=p1p2.....pj-1pjpn.....pk+1pkpk-1.....pj+1，这就是排列 p 的下一个排列。

证明见：

[全排列的实现方法--递归&字典序](https://blog.csdn.net/LaoJiu_/article/details/51115352?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)

```js
function permutationDictionary(str) {
    const array = Array.isArray(str) ? str : str.split('');

    if (array.length === 0) {
        return [];
    }

    array.sort();

    const res = [array.concat().join('')];

    let i;

    while (true) {
        for (i = array.length - 2; i >= 0; i--) {
            if (array[i] < array[i + 1]) {
                let index = 0;

                for (let j = array.length - 1; j > i; j--) {
                    if (array[j] > array[i]) {
                        index = j;
                        break;
                    }
                }

                [array[i], array[index]] = [array[index], array[i]];

                for (let s = i + 1, e = array.length - 1; s < e; s++, e--) {
                    [array[s], array[e]] = [array[e], array[s]];
                }
                res.push(array.concat().join(''));
                break;
            }
        }
        // 没有发生交换，跳出while
        if (i < 0) {
            break;
        }
    }

    return res;
}

console.log(permutationDictionary('aabc'));
```

字典序法自动去重，但只能实现整体的全排列，而不能实现递归法的选择其中几个元素。

### 动态规划

#### 连续子数组的最大和

例如：`[6, -3, -2, 7, -15, 1, 2, 2]`，最大子数组为 `[6, -3, -2, 7]` 和为 8。

1. 状态定义：**dp[i]表示以 i 结尾的连续子数组的最大和**。所以最终要求 dp[n-1]
2. 状态转移方程：dp[i] = max(array[i], dp[i-1]+array[i])
3. 解释：如果当前元素为整数，并且 dp[i-1]为负数，那么当然结果就是只选当前元素

具体描述：

```js
dp[0] = 6;
dp[1] = max(dp[0] + array[1], array[1]);
dp[2] = max(dp[1] + array[2], array[2]);
```

```js
function FindGreatestSumOfSubArray(array) {
    let dp = [];
    let ret = (dp[0] = array[0]);
    for (let i = 1; i < array.length; i++) {
        dp[i] = Math.max(dp[i - 1] + array[i], array[i]);
        ret = Math.max(dp[i], ret);
    }
    return ret;
}
```

#### 最大不重复子串

有一个字符串，现在让我们求出最大的不重复的连续的子串的长度，

例如：`abcabcbb` -> `abc`

1. 状态定义：**dp[i]表示以 i 结尾的最长连续子字符串**。
2. `dp[i]` 和 `dp[i-1]` 之间的关系：如果 `str[i]` 没有在 `dp[i-1]` 中出现，那 `dp[i]=dp[i-1]+str[i]`；如果出现了，假设出现的索引为 `dup`，那 `dp[i]` 的开始位置索引为 `start=dup+1`，即 `dp[i]=dp[i-1].substring(dup+1,dp[i].length)+str[i]`。

```js
function lengthOfLongestSubstring(str) {
    let maxStr = '';
    const dp = [];

    dp[0] = str[0];
    maxStr = dp[0].length;

    for (let i = 1; i < str.length; i++) {
        const index = dp[i - 1].indexOf(str[i]);

        dp[i] = dp[i - 1].slice(index + 1) + str[i];
        maxStr = Math.max(maxStr, dp[i].length);
    }
    return maxStr;
}
```

#### 最大回文字符串

1. 状态定义：**dp[i][j]表示子串[i...j]是否是回文字符串**。
2. 状态转移方程：`dp[i][j] = s[i]===s[j] && dp[i+1]dp[j-1]`；当 `j-i< 3` 时，`dp[i][j] = s[i]===s[j]`。
3. 初始：`dp[i][i] = true`。
4. 具体：循环字符串，得到 `j`，再依次判断 `[0...j] [1...j] ... [j-1...j]`（即：以 j 结尾的全部子字符串） 是否是回文字符串。这样可保证判断时 `[i...j]` 时，`[i+1...j-1]` 已经被判断了，因为 `j` 每向后移动一位，表示以 `j-1` 为尾的子字符串已经全部判断完毕。

```js
function longestPalindrome(str) {
    if (str.length === 0) {
        return;
    }
    const dp = [];
    let start = 0;
    let end = 0;

    for (let i = 0; i < str.length; i++) {
        dp[i] = [];
        dp[i][i] = true;
    }

    for (let j = 1; j < str.length; j++) {
        for (let i = 0; i < j; i++) {
            if (j - i < 3) {
                dp[i][j] = str[i] === str[j];
            } else {
                dp[i][j] = str[i] === str[j] && dp[i + 1][j - 1];
            }

            if (dp[i][j] && j - i > end - start) {
                start = i;
                end = j;
            }
        }
    }

    return str.slice(start, end + 1);
}
```

其他方法查看：[力扣面试题学习](https://blog.nowcoder.net/n/a7da88ae059d4708a5e93005fabe8836)

#### 背包问题

0-1 背包

题目：有一个容量为 c 的背包，和一些物品。这些物品分别有两个属性，体积 w 和价值 v，每种物品只有一个。要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。

1. 状态定义：**`dp[i][j]` 表示背包容量为 `j` 时，放入前 `i` 个物品时的最大价值**。
2. 对于一个物品，只有放与不放两种情况。如果不放，那 `dp[i][j]=dp[i-1][j]`；如果放，必须保证的是这个背包剩余的空间足够放下该物品，先为物品留出空间，求解留出空间后的背包在 `i-1` 个物品下能获取的最大价值 `dp[i-1][j-w[i]]`，再加上当前物品的价值，`dp[i-1][j-w[i]]+v[i]`。
3. 举例说明：
   这里的主体是物品，也就是说要确定**当前物品被放进去时，能产生的最大价值**。
   假设求 `dp[3][10]`：
    - 现在 w=5 的物品放进去，在容量为 10 下能产生的最大价值： `dp[2][5]`的值加上新物品的价值，假设为 `F`。
    - 但 `F` 可能并不是 `dp[3][10]`（表示的是容量为 10，放入前 3 个物品时最大价值），所以还需要与 `dp[2][10]` 比较。
    - 在状态定义中，描述的是 **前 `i` 个物品**，如果背包剩余空间足够， w=5 放进去，前 2 个物品还在，`F` 就是`dp[3][10]`；如果背包的剩余空间不足够，那自然是先放 w=5 的物品，在根据剩余空间放其他 2 个物品中的 1 个或是 0 个，这时就需要和原先的 `dp[2][10]` 比较了。
4. 状态转移方程，还需要考虑背包的容量是大于当前物品体积。

    - `j<w[i]，dp[i][j] = dp[i-1][j]`，背包装不下该物品，最大价值不变
    - `j>=w[i], dp[i][j] = max(dp[i-1][j-w[i]] + v[i], dp[i-1][j])`

```js
function backpackZeroOne(c, w, v) {
    if (v.length !== w.length) {
        return 0;
    }

    const nums = v.length;
    const dp = [];

    dp[0] = [];
    for (let i = 0; i <= c; i++) {
        // 初始放入0个物品，价值为0
        dp[0][i] = 0;
    }

    // dp[0] = []
    // dp[0][0] = 0
    // for (let i = 1; i <= c; i++) {
    //   // 初始放入0个物品，价值为0
    //   dp[0][i] = Number.NEGATIVE_INFINITY
    // }

    for (let i = 0; i < nums; i++) {
        // index表示第几个物品，索引从0开始，加1
        const index = i + 1;

        dp[index] = [];
        for (let j = 0; j <= c; j++) {
            if (j >= w[i]) {
                dp[index][j] = Math.max(dp[index - 1][j], dp[index - 1][j - w[i]] + v[i]);
            } else {
                dp[index][j] = dp[index - 1][j];
            }
        }
    }

    return dp[nums][c];
}

console.log(backpackZeroOne(5, [1, 2, 3], [5, 2, 8]));
```

变式：要求恰好装满背包时，把 `dp[0][0]`设为 0，其余 `dp[0][j]` 设为负无穷即可，这样只有恰好达到 dp[n][c]时，dp[n][c] 才为正值。

[动态规划-背包问题](https://www.cnblogs.com/yun-an/p/11037618.html)
[背包问题](https://blog.nowcoder.net/n/0917813a51f84915b1706d9347451a80)

完全背包

完全背包条件和上面一样，只是每个物品的数量无限个。

思路和上面一样，只是每个物品可以放多个，即：`dp[i-1][j - k*w[i]] + k*v[i]`。`k` 表示可以放多个同类物品。

```js
function backpackFull(c, w, v) {
    if (v.length !== w.length) {
        return 0;
    }

    const nums = v.length;
    const dp = [];

    dp[0] = [];
    for (let i = 0; i <= c; i++) {
        // 初始放入0个物品，价值为0
        dp[0][i] = 0;
    }

    for (let i = 0; i < nums; i++) {
        // index表示第几个物品，索引从0开始，加1
        const index = i + 1;

        dp[index] = [];
        for (let j = 0; j <= c; j++) {
            // 初始化为0
            dp[index][j] = 0;
            // 循环依次放入 k 个当前物品
            for (let k = 0; k <= j; k++) {
                // 当 k 个物品体积和大于背包体积时，跳出循环
                if (k * w[i] > j) {
                    break;
                }
                // 取每次最大值
                dp[index][j] = Math.max(dp[index][j], dp[index - 1][j - k * w[i]] + k * v[i]);
            }
        }
    }

    return dp[nums][c];
}

console.log(backpackFull(4, [1, 2, 3], [5, 11, 8]));
```

### 滑动窗口法

## 进程和线程

## 编程

### bind 实现

```js
function bind(fn, context) {
    if (typeof fn !== 'function') {
        throw new Error('argument(s) error');
    }

    const params = [].slice.call(arguments, 2);

    return function() {
        fn.call(context, ...params);
    };
}
```

### 前端路由

#### hash 模式

-   原理:

    在 url 中的 # 之后对应的是 hash 值, 其原理是通过 hashChange() 事件监听 hash 值的变化, 根据路由表对应的 hash 值来判断加载对应的路由加载对应的组件

-   优点:

    1. 只需要前端配置路由表, 不需要后端的参与
    2. 兼容性好, 浏览器都能支持
    3. hash 值改变不会向后端发送请求, 完全属于前端路由

-   缺点:

    1. hash 值前面需要加#, 不符合 url 规范,也不美观

```js
function Router() {
    this.routes = {};
}

Router.prototype.add = function(path, callback) {
    this.routes[path] = callback || function() {};
};

Router.prototype.push = function(path) {
    location.hash = path;
};

Router.prototype.init = function() {
    const hashChange = () => {
        const currentUrl = location.hash.slice(1) || '/';

        this.routes[currentUrl] && this.routes[currentUrl]();
    };

    // 第一次进入页面时
    window.addEventListener('load', hashChange, false);
    window.addEventListener('hashchange', hashChange, false);
};

const router = new Router();

router.init();
router.add('/home', () => {
    console.log('this is home page');
});
router.push('/home');
```

#### history 模式

-   原理:

    利用 pushState() 和 replaceState() 方法，onpopState 监听浏览器前进后退

-   优点:

    1. 符合 url 地址规范, 不需要#, 使用起来比较美观

-   缺点:

    1. 在用户手动输入地址或刷新页面时会发起 url 请求, 后端需要配置 index.html 页面用户匹配不到静态资源的情况, 否则会出现 404 错误
    2. 兼容性比较差, 是利用了 HTML5 History 对象中新增的 pushState() 和 replaceState() 方法,需要特定浏览器的支持.

```js
function Router() {
    this.routes = {};
}

Router.prototype.add = function(path, callback) {
    this.routes[path] = callback || function() {};
};

Router.prototype.push = function(path) {
    // 可以通过 history.state 读取
    const state = {
        route: path
    };

    history.pushState(state, null, path);
    this.routes[path] && this.routes[path]();
};

Router.prototype.init = function() {
    const pathChange = (e) => {
        console.log(e.state);

        const path = location.pathname;

        this.routes[path] && this.routes[path]();
    };

    // 第一次进入页面时
    window.addEventListener('load', pathChange, false);
    window.addEventListener('popstate', pathChange, false);
};

const router = new Router();

router.init();
router.add('/home', () => {
    console.log('this is home page');
});
router.push('/home');
```

## 数据结构

https://cloud.tencent.com/developer/ask/112047

### 队列

队列（queue）是只允许在**一端进行插入操作**，而在**另一端进行删除操作**的线性表。

队列是一种**先进先出**（First in First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。

### 二叉树

https://blog.csdn.net/qq_36903042/article/details/100798101

### 链表

链表的插入删除时间复杂度时 O(1)，查询的时间复杂度为 O(n)。
但链表在插入删除时，需要遍历找到插入的节点，这样它时间复杂度还是 O(n)。
如果已经知道节点，那插入的时间复杂度 O(1)。

双链表：每个节点有 next 和 pre 两个指针。

循环链表：尾节点的 next 指向头节点，即 `tail.next=head`。

```js
class Node {
    constructor(value, next, pre) {
        this.value = value;
        this.next = next;
        this.pre = pre;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
    }

    append(value) {
        const node = new Node(value);

        if (this.head) {
            node.next = this.head;
            this.head = node;
        } else {
            this.head = node;
        }
    }

    getIndex(value) {
        let index = 0;
        let node = this.head;

        while (node) {
            if (node.value === value) {
                return index;
            }
            node = node.next;
            index++;
        }
        return -1;
    }

    findByValue(value) {
        let node = this.head;

        while (node) {
            if (node.value === value) {
                return node;
            }
            node = node.next;
        }
        return null;
    }

    findByIndex(index) {
        let currentIndex = 0;
        let node = this.head;

        while (node) {
            if (currentIndex === index) {
                return node;
            }
            node = node.next;
            currentIndex++;
        }
        return null;
    }

    findPreNode(value) {
        let node = this.head;

        while (node && node.next) {
            if (node.next.value === value) {
                return node;
            }
            node = node.next;
        }
        return null;
    }

    insert(value, newValue) {
        const node = this.findByValue(value);

        if (node) {
            const newNode = new Node(newValue);

            newNode.next = node.next;
            node.next = newNode;
        }
    }

    remove(value) {
        const preNode = this.findPreNode(value);

        if (this.head.value === value) {
            this.clear();
        }

        if (preNode) {
            preNode.next = preNode.next.next;
        }
    }

    size() {
        let size = 0;
        let node = this.head;

        while (node) {
            size++;
            node = node.next;
        }
        return size;
    }

    clear() {
        this.head = null;
    }
}

const list = new LinkedList();

list.append('a');
console.log(list);
list.append('b');
console.log(list);
list.insert('a', 'c');
console.log(list);
list.insert('c', 'd');
console.log(list);
list.remove('a');
console.log(list);
list.remove('b');
console.log(list);
```

## 发布订阅（事件分发）和 观察者

发布订阅比观察者多了一个调度中心。

https://segmentfault.com/a/1190000018706349

## 前端通用组件

单一职责

细粒度，恰到好处，可以被多处复用

通用性，足够的可定制空间

https://juejin.im/post/6844903847874265101#heading-4

移动端：
https://zhuanlan.zhihu.com/p/137539250

软键盘弹出，导致 fixed 定位的元素遮挡按钮。

监听`resize`或者输入框`focus`事件，改变遮挡按钮的位置。
https://blog.csdn.net/qq_33834489/article/details/80450950

click 事件和 touch 事件冲突，点击穿透
B 元素在 A 元素之上，B 元素的 touchstart 事件上注册了一个回调函数，该回调函数的作用是隐藏 B 元素。我们发现，当我们点击 B 元素，B 元素被隐藏了，B 在 300ms 后产生的 click 事件由于找不到 B,B 会把 click 事件强行加给 A 执行，这个过程就叫点击穿透
解决: touchstart 阻止默认事件

touch 事件和页面滑动（上下滑动，顶部下滑刷新）冲突

## 主题切换

https://www.jianshu.com/p/35e0581629d2

## 前端架构

目录结构

公共资源（组件、配置、函数、样式、接口、图片字体、状态管理等）

中间件（接口拦截、路由拦截、权限管理、数据注入等）

代码规范——eslint

提交规范

测试

http://www.h-camel.com/show/1787.html

## 如何写出高质量的库

职责单一

注释

命名规则的统一

eslint

分清私有属性和对外属性，可提供哪些 api

内部数据的定义，比如当前鼠标对象

事件（发布订阅）

通用性，足够的配置参数

## 高阶函数

https://segmentfault.com/a/1190000018528025

### 柯里化

柯里化常见的应用有：参数复用、延迟计算。

```js
function curry(fn) {
    let args = Array.prototype.slice.call(arguments, 1);
    return function() {
        let innerArgs = Array.prototype.slice.call(arguments);
        let finalArgs = args.concat(innerArgs);
        if (finalArgs.length < fn.length) {
            //fn.length为函数的参数个数
            return curry.call(this, fn, ...finalArgs);
        } else {
            return fn.apply(null, finalArgs);
        }
    };
}
```

### 组合函数

组合函数类似于管道，多个函数的执行时，上一个函数的返回值会自动传入到第二个参数继续执行。

```js
function compose() {
    var args = arguments;
    var start = 0;
    return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (++i < args.length) result = args[i].call(this, result);
        return result;
    };
}
```

函数可能有多个参数，例如 `f(a,b,c)` 和 `g(e,f)` ，要将`f(a,b,c)`的值作为一个参数传递给 `g`。

这时就需要柯里化和组合函数一起使用：

```js
function compose() {
    var fns = [...arguments].map((fn) => curry(fn));
    var c = 0;
    return function() {
        var i = c;
        let args = arguments;
        while (i < fns.length) {
            var result = fns[i].apply(this, args);
            if (typeof resulit === 'function') {
                return result;
            }
            args = [result];
            i++;
            c++;
        }
        return result;
    };
}
```

## 主流框架的区别

vue 模板语法，react JSX 语法。

vue 会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树。React 默认每当状态被改变时,全部子组件都会重新渲染

https://blog.csdn.net/qq_26190177/article/details/93741368

## 事件委托的优点

1. 减少事件注册，节省内存
2. 对新加的节点也可以处理

缺点：

1. 冒泡过程中，可能会被某层阻止掉

## data 必须是一个函数

data 值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果 data 值为对象，将导致多个实例共享一个对象，其中一个组件改变 data 属性值，其它实例也会受到影响。

## vuex 将所有组件数据抽取到 vuex 中

## 重复性工作应该怎么处理

## 如何学习一个新技术

## 一个 bug 是偶然重现如何解决

## vuepress 为啥打包有 client 和 server

## 不支持 webp 的浏览器如何去支持

## 捕捉错误并上报

`window.onerror` 事件。

webpack 开启 sourcemap。

Vue.config.errorHandler

## 逻辑算法题

1. 有 16 瓶水，其中只有一瓶水有毒，小白鼠喝一滴之后一小时会死，请问最少用多少只小白鼠，在 1 小时的时间一定可以找出有毒的水？
   2^4=16 故需要 4 只。
   假设用 n 只老鼠，每只老鼠有死与不死两种情况，故所有老鼠的死亡存活情况总共 2^n 种。
   如果只有 A 老鼠死代表第 1 瓶有毒，只有 B 老鼠死代表第 2 瓶有毒，只有 AB 老鼠死代表第三瓶有毒，依次类推。可以用所有情况分别唯一代表某瓶水有毒。故 2^n=16，所以只需要 4 只老鼠，它们的死亡组成情况即可代表某瓶水有毒的所有情况。
   A 0 0 0
   B 0 0 0 ......
   C 0 1 1
   D 1 0 1
   每一行代表老鼠喝了哪些水。如果 D 死亡代表第一瓶水有毒，C 死亡代表第二瓶水，CD 死亡代表第三瓶水，以此类推。

## js 垃圾回收

新生代，Scavenge 算法：

1. 将新生代内存空间一分为二。
2. 其中 From 部分表示正在使用的内存，To 是目前闲置的内存。
3. 当进行垃圾回收时，V8 将 From 部分的对象检查一遍，如果是**存活对象那么复制到 To 内存**中(在 To 内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。
4. 当所有的 From 中的存活对象按照顺序进入到 To 内存之后，From 和 To 两者的角色对调，From 现在被闲置，To 为正在使用，如此循环。

分为 2 块，不断复制的原因：解决垃圾回收而导致的内存碎片化问题。

老生代：

新生代会晋升到老生代：

1. 已经经历过一次 Scavenge 回收。
2. To（闲置）空间的内存占用超过 25%。

老生代采用标记清除法：

首先会遍历堆中的所有对象，对它们**做上标记**，然后对于代码环境中**使用的变量以及被强引用的变量取消标记**，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。

https://juejin.im/post/6844904004007247880#heading-3

## 项目中遇到的不足

## 我的优缺点

## 最满意的事

## 遇到的困难

## 见过最好的代码

## 看过的书

## 最新学习的技术

## 最大的优点

学习能力强，喜欢思考和专研来解决问题。

## 最大的缺点

项目架构上有所欠缺，比如我自己做的项目，特别是第一个项目，对目录、资源文件、接口、插件等就重构了好几次。后面我也做了一些总结记录，在后面项目中就清晰了很多。

## 最近遇到的难点

工作：ldap 树。

个人：路由插件、弹球小游戏碰撞和反射。

## 工作环境和团队

## 和同事意见不统一

## 新项目如何学习

https://juejin.im/post/6844903986210816013#heading-14
https://juejin.im/post/6844904052577271822#heading-1

https://wenku.baidu.com/view/0380880abb68a98271fefa78.html
https://blog.csdn.net/Hningning/article/details/108453993
