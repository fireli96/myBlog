# wxa 的一些优化

[wxa](https://webank.gitee.io/wxa/) 是一个好用的小程序框架，但也有许多问题和可以优化的地方，最近的一段时间，我尝试为 `wxa` 增加了一些新功能，主要包括以下的几点。

## 依赖分离

依赖分离：指将分包独有的依赖打包进分包。在现有的部分小程序框架中，例如：`taro`, `uni-app`，都支持依赖分离，但它们都有一些问题：

1. `taro` 的依赖分离要针对每一个依赖做配置，并且当多个分包引用同一依赖时，这个依赖只能被打包进主包。
2. `uni-app` 的依赖分离只支持 `node_modules` 中的文件。

`wxa` 也支持依赖分离，但同样只支持 `node_modules` 中的文件，最主要的是 `wxa` 的依赖分离有严重 `bug`。因此我重写了 `wxa` 的依赖分离逻辑，现在这部分逻辑有更明确的步骤：收集主分包依赖 -> 分析依赖 -> 过滤依赖 -> 输出依赖，便于将来可能的对这部分更多的扩展。

同时 `wxa` 的依赖分离现在已经支持 **本地文件** 和 `node_modules` 中文件，并可以根据 **被分包引用个数** 和 **依赖大小** 决定依赖被打包到主包或是分包。

**为什么需要依赖分离？**

这允许你能放心将全部公共函数和公共组件放在主包目录，即使某些公共函数和组件 **只被一个分包引用**。

因为小程序不能跨分包引用代码，公共函数和组件全部放入主包是解决办法，而依赖分离是解决这个方法造成的主包冗余问题。

但在未来，[分包异步化](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html) 的出现可能带来新的解决方案：可以用一个 **公共分包** 来存放公共组件（函数），当需要的时候，其他分包使用这个 **公共分包** 的代码。这样既不会造成主包冗余，又能跨分包使用代码。

## tree shake

基于历史原因，`wxa` 的并没有使用 `webpack` 打包，所以也就不支持 `tree shake`。

`tree shake` 是基于 `es6` 静态模块语法去删除未被使用的模块，一个完整的 `tree shake` 过程分为以下两步：

1. 跨文件分析导出模块是否被导入（已经实现）。
2. 分析未被导入的导出模块是否在本文件内部使用（简单实现），但可以借助 `terser` 工具处理。

除此之外，`wxa` 的 `tree shake` 也会尝试处理 `commonjs` 模块，`es6` 模块如果是经过 `webpack` 或者 `rollup` 打包生成的 `cjs` 模块，这里也能处理。

`tree shake` 在现在看来用处有限，原因之一是 `npm` 模块都是 `commonjs` 语法，但随着浏览器对 `es6` 模块支持的普及，未来 `es6` 模块可能会成为主流。

## hook

`react` 支持函数式组件和类组件，但函数式组件没有状态和生命周期，只能做简单的渲染，而 `hook` 的出现让函数式组件能平等替代类组件。

函数式组件相比类组件有着更高的复用性和可维护性：

1. 函数式组件可以将功能拆分为一个个函数，这些功能函数容易被其他组件复用。
2. 相同功能的代码可以组织在一起。

`wxa` 的 `hook` 方案基于原生小程序特性，内部封装了小程序 `Component` 构造器，实现了自己的组件实例化、更新流程。

现在已经基本完成 [wxa-hook](http://git.weoa.com/mumblefe/wxa-hook/tree/dev-v3)，但其稳定性还需要实际试验。
