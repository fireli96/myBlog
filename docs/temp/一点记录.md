## 浏览器 ES6 模块

webpack Bundle，所有依赖合并成一个或者多个 bundle，首页加载慢，同时单个文件的改变也会造成 bundle 的改变，浏览器缓存失效。

浏览器 es6 模块，可做到按文件级别的按需加载，首页最小化体积。单个文件改变只会造成单个文件的缓存失效。

es6 模块加载原理：浏览器从 ES Module 入口文件开始解析，找到导入语句的模块说明符，然后下载文件，继续解析，全部解析之后才会通过深度优先的后序遍历进行模块实例化。

那么不被首页引入的文件就必然不会被下载。但同时，这需要对每一个文件进行 http 请求下载，而且子依赖文件的下载依赖于父依赖已经被下载，这会造成请求瀑布的问题。

解决方案：

1. 使用 http 2.0，http2 的帧（frame）和流（stream）设计，以及基于一个 `tcp` 链接，持续进行以 `frame` 为最小单位的并行数据传输。
2. 但 `http2` 只能当做一个优化，本质上产生请求瀑布问题的原因是，一个模块下载依赖父模块已经下载完成。这时可以借助 modulepreload 来做优化：

    ```html
    <link rel="modulepreload" href="lib.mjs" />
    <link rel="modulepreload" href="main.mjs" />
    <script type="module" src="main.mjs"></script>
    <script nomodule src="fallback.js"></script>
    ```

但事实上，es6 并不适合在大型生产项目中使用，它适用于：

1. 本地开发环境中
2. 在总模块少于 100 和依赖树相对较浅（即，最大深度小于 5）的小型 Web App 中

产生请求瀑布的原因在于模块过多以及模块嵌套过深，只要解决这 2 个方面的问题，那 es6 模块在浏览器中就有着绝对的优势，为此可以结合 `Bundle` 来做到：

1. 将一些边缘未被引用多次的文件合并到一个 `bundle` 中
2. 将嵌套过深的模块 `bundle` 到父依赖中。

### importmap

importmap 实现支持裸导入说明符

```html
<script type="importmap">
    {
        "imports": {
            "moment": "/node_modules/moment/src/moment.js",
            "lodash": "/node_modules/lodash-es/lodash.js"
        }
    }
</script>

<script type="module">
    import moment from 'moment';
    import { partition } from 'lodash';
</script>
```

[现代 Web 应用应该是 Bundless 的](https://mp.weixin.qq.com/s/Dy5ys9TaosY9YKD0iKb70g)

## 无痕埋点方案

### 配置

维护一个 `JSON` 配置，存储所有埋点信息。

为什么要使用 `JSON` 配置存储所有埋点信息？

这是为了将埋点集中管理，这样能快速统计所有埋点、修改埋点、删除无用埋点等。

同时采用配置的方式，在真正触发埋点的地方无需关注埋点的具体信息，只需要很简单触发即可，一定程度减少与业务代码的耦合。

最后，这种方式将带来更多的扩展，例如：在配置中描述埋点的具体触发元素，再通过全局事件监听（或是编译注入埋点代码等方式），可以做到只需增加配置就能直接实现埋点。

### 指令和 AOP

采用自定义指令的方式和 `AOP` 的方式，将埋点与业务代码分离。类似于以下库的实现：

1. [v-track](https://github.com/l-hammer/v-track)

    ```html
    <!-- 页面行为埋点（track-view为v-track全局注册的组件） -->
    <track-view v-track:18015></track-view>
    <track-view v-track:18015.watch="{ rest }"></track-view>
    <track-view v-track:18015.watch.delay="{ rest }"></track-view>
    <track-view v-if="rest" v-track:18015></track-view>

    <!-- 事件行为埋点（DOM） -->
    <div v-track:18015.click="handleClick"></div>
    <div v-track:18015.click="{ handleClick, item, index }"></div>
    <div v-track:18015.click.async="{ handleSearch, rest }"></div>
    <div v-track:18015.click.delay="handleClick"></div>

    <!-- 事件行为埋点（组件） -->
    <cmp v-track:18015.click="handleClick"></cmp>
    <cmp v-track:18015.[自定义事件名]="handleSearch"></cmp>
    <cmp v-track:18015.[自定义事件名].delay="handleSearch"></cmp>
    <cmp v-track:18015.[自定义事件名].async="{ handleSearch, rest }"></cmp>

    <!-- 区域展现埋点（block 可以是 DOM 或者组件） -->
    <block v-track:18015.show></block>
    <block v-track:18015.show.once></block>
    <block v-track:18015.show.custom="{ ref: 'scroll' }"></block>
    <block v-track:18015.show.custom.once="{ ref: 'scroll' }"></block>
    ```

2. [trackpoint-tools](https://github.com/Qquanwei/trackpoint-tools)

    ```js
    class SomeComponent {
        @track(before(() => console.log('before')))
        onClick() {
            console.log('click');
        }
    }
    ```

## 状态管理之有限状态机

前端代码的复杂度和状态成比例关系，体现如下：

1. 各种各样的业务状态导致的 flag 变量的剧增：即便是自己，写多了这种变量，也很难清楚的知道每个 flag 是干什么用的。
2. 各种判断业务状态的 if/else：if/else 嵌套地狱估计在很多大型的业务产品中都能看到吧。还有内部的各种逻辑判断，如 isA && isB || !(isC || !isD && isE)，完全看不懂，即便问 PD，时间久了她也不知道了。还有因此可能导致一些意识不到的 Bug。

总结而言，过多的状态变量导致后续无法维护无法知道这些状态变量的含义，过多的分支语句导致代码难以理解。

作者举了一个搜索框的例子：

```js
function onSearch(keyword) {
    if (this.state.isLoading) {
        return;
    }
    this.fetchAbort = new AbortController();

    this.setState({
        isLoading: true,
        isError: false
    });

    fetch(SEARCH_URL + '?keyword=' + keyword, {
        signal: this.fetchAbort.signal
    })
        .then(data => {
            this.setState({ data, isLoading: false });
        })
        .catch(e => {
            // 取消请求
            if (e.name == 'AbortError') {
                this.setState({
                    isLoading: false
                });
            } else {
                this.setState({
                    isError: true,
                    isLoading: false
                });
            }
        });
}

// 取消搜索
function onCancel() {
    this.fetchAbort.abort();
}
```

在这个例子中，需要处理的状态如下：

1. 搜索进行时 Loading ，无法进行下一次搜索
2. 搜索成功，显示数据列表， Loading
3. 搜索失败，分两种情况：1. 请求失败，显示搜索错误， Loading 置位为 false；2. 搜索是被取消， Loading

写出来的代码如上，需要在各个地方扭转不同 `flag` 变量，以及各种 `if` 分支语句。

真实的业务场景可能比这个场景复杂 `N` 倍。

但如果用状态机描述上诉过程，其实本质是状态的改变，状态何时被改变，状态能被扭转为其他什么状态。

```json
{
    "initial": "空闲",
    "states": {
        "空闲": {
            "on": {
                "搜索": "搜索中"
            }
        },
        "搜索中": {
            "on": {
                "搜索成功": "成功",
                "搜索失败": "失败",
                "取消": "空闲"
            }
        },
        "成功": {
            "on": {
                "搜索": "搜索中"
            }
        },
        "失败": {
            "on": {
                "搜索": "搜索中"
            }
        }
    }
}
```

状态机包含以下四个方面：

1. 状态 State
2. 事件 Event ，事件描述在何时转换状态
3. 动作 Action ，进入/离开 状态时，触发的行为，一般为一个函数
4. 转换 Transition， 描述状态改变的过程，并得到下一个状态

一般来说，我们需要：

1. 定义一个变量来表示状态
2. 定义多个事件枚举，不同状态会监听不同事件。
3. 定义多个行为函数，表示状态转换时，需要触发的逻辑。
4. 定义事件触发函数，每次调用事件触发函数并传入对应事件枚举，来完成状态转换。

这些逻辑已经被 [Xstate](https://lecepin.github.io/xstate-docs-cn/zh/) 实现，并拥有更多的特性。

我们可能不习惯引入这样一个规范的写法。但在状态定义时至少应该做到以下几点：

1. 抽象。当定义一个状态时，思考这是怎样一个功能模块，用一个变量表示多个状态。
2. 单个定义状态改变时，需要执行的逻辑函数。
3. 监听状态或者提供一个统一的改变状态函数，来完成状态改变需要执行的逻辑函数。

为何这样做，可以做到更高的可维护性，原因如下：

1. 我们定义了更少的 flag 变量。
2. 天然进行函数拆分，避免所有逻辑写在一个函数内部，提供更高的可复用性和可维护性。
3. 状态的改变是更易追踪的，并且我们能直接知晓，当状态改变时，会执行何种逻辑。即：我们只需去追踪单个状态的改变，便能得到在何时会触发怎样的逻辑（状态改变时的逻辑函数），而不会将状态耦合在逻辑函数中。

### 参考

1. [降低前端业务复杂度新视角：状态机范式](https://mp.weixin.qq.com/s/SivN4Cbn1RRakEVuenZrHg)
2. [Xstate - JavaScript 状态机和状态图](https://lecepin.github.io/xstate-docs-cn/zh/)

## 业务代码可维护性
