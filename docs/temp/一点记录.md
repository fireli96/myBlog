## 浏览器 ES6 模块

webpack Bundle，所有依赖合并成一个或者多个 bundle，首页加载慢。

浏览器 es6 模块，可做到按文件级别的按需加载，首页最小化体积。

es6 模块加载原理：浏览器从 ES Module 入口文件开始解析，找到导入语句的模块说明符，然后下载文件，继续解析，全部解析之后才会通过深度优先的后序遍历进行模块实例化。

那么不被首页引入的文件就必然不会被下载。但同时，这需要对每一个文件进行 http 请求下载，而且子依赖文件的下载依赖于父依赖已经被下载，这会造成请求瀑布的问题。

解决方案：

1. 使用 http 2.0，http2 的帧（frame）和流（stream）设计，以及基于一个 `tcp` 链接，持续进行以 `frame` 为最小单位的并行数据传输。
2. 但 `http2` 只能当做一个优化，本质上产生请求瀑布问题的原因是，一个模块下载依赖父模块已经下载完成。这时可以借助 modulepreload 来做优化：

    ```html
    <link rel="modulepreload" href="lib.mjs" />
    <link rel="modulepreload" href="main.mjs" />
    <script type="module" src="main.mjs"></script>
    <script nomodule src="fallback.js"></script>
    ```

但事实上，es6 并不适合在大型生产项目中使用，它适用于：

1. 本地开发环境中
2. 在总模块少于 100 和依赖树相对较浅（即，最大深度小于 5）的小型 Web App 中

产生请求瀑布的原因在于模块过多以及模块嵌套过深，只要解决这 2 个方面的问题，那 es6 模块在浏览器中就有着绝对的优势，为此可以结合 `Bundle` 来做到：

1. 将一些边缘未被引用多次的文件合并到一个 `bundle` 中
2. 将嵌套过深的模块 `bundle` 到父依赖中。

### importmap

importmap 实现支持裸导入说明符

```html
<script type="importmap">
    {
        "imports": {
            "moment": "/node_modules/moment/src/moment.js",
            "lodash": "/node_modules/lodash-es/lodash.js"
        }
    }
</script>

<script type="module">
    import moment from 'moment';
    import { partition } from 'lodash';
</script>
```

## 无痕埋点方案

### 配置

维护一个 `JSON` 配置，存储所有埋点信息。

为什么要使用 `JSON` 配置存储所有埋点信息？

这是为了将埋点集中管理，这样能快速统计所有埋点、修改埋点、删除无用埋点等。

同时采用配置的方式，在真正触发埋点的地方无需关注埋点的具体信息，只需要很简单触发即可，一定程度减少与业务代码的耦合。

最后，这种方式将带来更多的扩展，例如：在配置中描述埋点的具体触发元素，再通过全局事件监听（或是编译注入埋点代码等方式），可以做到只需增加配置就能直接实现埋点。

### 指令和 AOP

采用自定义指令的方式和 `AOP` 的方式，将埋点与业务代码分离。类似于以下库的实现：

1. [v-track](https://github.com/l-hammer/v-track)

    ```html
    <!-- 页面行为埋点（track-view为v-track全局注册的组件） -->
    <track-view v-track:18015></track-view>
    <track-view v-track:18015.watch="{ rest }"></track-view>
    <track-view v-track:18015.watch.delay="{ rest }"></track-view>
    <track-view v-if="rest" v-track:18015></track-view>

    <!-- 事件行为埋点（DOM） -->
    <div v-track:18015.click="handleClick"></div>
    <div v-track:18015.click="{ handleClick, item, index }"></div>
    <div v-track:18015.click.async="{ handleSearch, rest }"></div>
    <div v-track:18015.click.delay="handleClick"></div>

    <!-- 事件行为埋点（组件） -->
    <cmp v-track:18015.click="handleClick"></cmp>
    <cmp v-track:18015.[自定义事件名]="handleSearch"></cmp>
    <cmp v-track:18015.[自定义事件名].delay="handleSearch"></cmp>
    <cmp v-track:18015.[自定义事件名].async="{ handleSearch, rest }"></cmp>

    <!-- 区域展现埋点（block 可以是 DOM 或者组件） -->
    <block v-track:18015.show></block>
    <block v-track:18015.show.once></block>
    <block v-track:18015.show.custom="{ ref: 'scroll' }"></block>
    <block v-track:18015.show.custom.once="{ ref: 'scroll' }"></block>
    ```

2. [trackpoint-tools](https://github.com/Qquanwei/trackpoint-tools)

    ```js
    class SomeComponent {
        @track(before(() => console.log('before')))
        onClick() {
            console.log('click');
        }
    }
    ```
