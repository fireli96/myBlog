## HTTP

### 特点

简单快速、灵活、无连接、无状态 HTTP 三点注意事项：

- HTTP 是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- HTTP 是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 内容类型。
- HTTP 是无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

### Http 缓存策略

强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的 Etag 和 Last-Modified
通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。

HTTP 缓存都是从第二次请求开始的：

第一次请求资源时，服务器返回资源，并在 response header 中回传资源的缓存策略；
第二次请求时，浏览器判断这些请求参数，击中强缓存就直接 200，否则就把请求参数加到 request header 头中传给服务器，看是否击中协商缓存，击中则返回 304，否则服务器会返回新的资源。

1. 强缓存

   - 强缓存命中则直接读取浏览器本地的资源，在 network 中显示的是 from memory 或者 from disk
   - **控制强制缓存的字段有：Cache-Control（http1.1）和 Expires（http1.0）**
   - Cache-control 是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。
   - Expires 是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求
   - Cache-Control 的优先级比 Expires 的优先级高。前者的出现是为了解决 Expires 在浏览器时间被手动更改导致缓存判断错误的问题。
   - 如果同时存在则使用 Cache-control。

2. 协商缓存
   - 协商缓存的状态码由服务器决策返回 200 或者 304
   - 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属 性。
   - 对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。
   - **协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和 Etag/If-None-match（http1.1）**
   - Last-Modified/If-Modified-since 表示的是服务器的资源最后一次修改的时间；
   - Etag/If-None-match 表示的是服务器资源的唯一标识，只要资源变化，Etag 就会重新生成。
   - Etag/If-None-match 的优先级比 Last-Modified/If-Modified-since 高。

[说一下 Http 缓存策略，有什么区别，分别解决了什么问题](https://github.com/lgwebdream/FE-Interview/issues/14)

### get、post 的区别

1. get 传参方式是通过地址栏 URL 传递，是可以直接看到 get 传递的参数，post 传参方式参数 URL 不可见，get 把请求的数据在 URL 后通过？连接，通过&进行参数分割。psot 将参数存放在 HTTP 的包体内
2. get 传递数据是通过 URL 进行传递，对传递的数据长度是受到 URL 大小的限制，URL 最大长度是 2048 个字符。post 没有长度限制
3. get 后退不会有影响，post 后退会重新进行提交
4. get 请求可以被缓存，post 不可以被缓存
5. get 请求只 URL 编码，post 支持多种编码方式
6. get 请求的记录会留在历史记录中，post 请求不会留在历史记录
7. get 只支持 ASCII 字符，post 没有字符类型限制

### 响应码

1xx(临时响应)

100: 请求者应当继续提出请求。

101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。

2xx(成功)

200：正确的请求返回正确的结果

201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。

202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。

3xx(已重定向)

300：请求成功，但结果有多种选择。

301：请求成功，但是资源被永久转移。

303：使用 GET 来访问新的地址来获取资源。

304：请求的资源并没有被修改过

4xx(请求错误)

400：请求出现错误，比如请求头不对等。

401：没有提供认证信息。请求的时候没有带上 Token 等。

402：为以后需要所保留的状态码。

403：请求的资源不允许访问。就是说没有权限。

404：请求的内容不存在。

5xx(服务器错误)

500：服务器错误。

501：请求还没有被实现。

### TCP 三次握手

https://juejin.im/post/6844904152850497544#heading-60

https://juejin.im/post/6844903935669436424#heading-1

### HTTP2.0

https://juejin.im/post/6844904100035821575#heading-91

#### HTTP1.x 的缺点

1. 队头阻塞。
   Chrome 有个机制，对于同一个域名，默认允许同时建立 6 个 TCP 持久连接，使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。
2. 单向请求，只能由客户端发起。
3. 请求报文与响应报文首部信息冗余量大。
4. 明文传输

#### HTTP2.0 特点

1. 二进制传输
   把原来的"Header+Body"的消息"打散"为数个小片的二进制"帧"(Frame),用"HEADERS"帧存放头数据、"DATA"帧存放实体数据。HTP/2 数据分帧后"Header+Body"的报文结构就完全消失了，协议看到的只是一个个的"碎片"。
2. 多路复用
   HTTP2.0 中，有两个概念非常重要：帧（frame）和流（stream）。
   帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
   所谓多路复用，即在一个 TCP 连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免 HTTP 旧版本的队头阻塞问题，极大提高传输性能。
3. Header 压缩
4. 服务器 push
5. 更安全

缺点：

1. TCP 以及 TCP+TLS 建立连接的延时
2. TCP 的队头阻塞并没有彻底解决
   TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP 连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

https://juejin.im/post/6844904152850497544#heading-60

### 从输入 URL 到页面加载发生了什么？

1. 浏览器会进行 DNS 域名解析，拿到域名对应的服务器 ip 地址，再用该 ip 去访问 web 服务器
2. 然后会和 web 服务器进行 tcp 的三次握手建立 tcp 连接
3. 连接建立成功后，浏览器会发送 http 的 get 请求
4. 服务器收到请求并给予响应，返回请求的数据
5. 浏览器拿到数据并进行解析、渲染
6. 浏览器和服务器进行 tcp 的四次挥手，断开连接

https://segmentfault.com/a/1190000006879700#comment-area

### HTTPS

简单来说，如果是对称加密，那在传输数据前，必然会传输一次密钥，那就可能被中间人拿到这个密钥。

如果是非对称加密，那也必须去传输一次公钥，客户端只持有公钥，服务端持有私钥（公钥加密私钥能解密，私钥加密公钥解密），服务端传输的数据只能是私钥加密，而公钥所有人都知道。非对称只能保证单端传输安全。

两者结合，服务端给予公钥给浏览器，浏览器生成一个密钥并用公钥加密，再将加密的密钥数传给服务端，服务端用私钥解密。这样两边都有这个密钥，用这个密钥对称加密。

这个密钥难以被中间人拿到，它只传输过一次，并且被公钥加密。

具体如下：
https://juejin.im/post/6844904021308735502#heading-84

## websocket

tcp 三次握手
发了一个 http 请求，用于协议升级
服务器如果支持 websocket 协议的话，会返回 101 状态码表示同意协议升级，
完成了协议的升级，后续的数据通信，就是基于 tcp 连接之上，使用 websocket 协议封装的数据包。

## JS

### 闭包

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

优点：

1. 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用
2. 避免变量污染全局

   模块封装，例如 jquert

3. 把变量存到独立的作用域，作为私有成员存在

缺点：

1. 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏
2. 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度
3. 可能获取到意外的值(captured value)

应用：

1. 循环闭包
2. 封装模块，（变量私有化，避免污染全局）
3. 缓存

### 类数组

数组是一个特殊对象,与常规对象的区别：

1. 当由新元素添加到列表中时，自动更新 length 属性
2. 设置 length 属性，可以截断数组
3. 从 Array.protoype 中继承了方法
4. 属性为'Array'

类数组是一个拥有 length 属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。

类数组转换为数组：

- 使用 Array.from()
- 使用 Array.prototype.slice.call()
- 使用 Array.prototype.forEach() 进行属性遍历并组成新的数组
- 展开运算符

### promise

1. Promise 基本特性

   1. Promise 有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)
   2. Promise 对象接受一个回调函数作为参数, 该回调函数接受两个参数，分别是成功时的回调 resolve 和失败时的回调 reject；另外 resolve 的参数除了正常值以外， 还可能是一个 Promise 对象的实例；reject 的参数通常是一个 Error 对象的实例。
   3. then 方法返回一个新的 Promise 实例，并接收两个参数 onResolved(fulfilled 状态的回调)；onRejected(rejected 状态的回调，该参数可选)
   4. catch 方法返回一个新的 Promise 实例
   5. finally 方法不管 Promise 状态如何都会执行，该方法的回调函数不接受任何参数

2. Promise 优点

   - 统一异步 API
     - Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。
   - Promise 与事件对比
     - 和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。 Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。
   - Promise 与回调对比
     - 解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。
   - Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如 Array.prototype.map() ）。

3. Promise 缺点

   - 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。
   - 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。
   - 当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
   - Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。

```js
function promiseAll(promises) {
  return new Promise(function(resolve, reject) {
    if (!Array.isArray(promises)) {
      throw new TypeError(`argument must be a array`)
    }
    var resolvedCounter = 0
    var promiseNum = promises.length
    var resolvedResult = []
    for (let i = 0; i < promiseNum; i++) {
      Promise.resolve(promises[i]).then(
        (value) => {
          resolvedCounter++
          resolvedResult[i] = value
          if (resolvedCounter == promiseNum) {
            return resolve(resolvedResult)
          }
        },
        (error) => {
          return reject(error)
        }
      )
    }
  })
}
```

### 数组转树

```js
function array2Tree(array, parentFlag = 'parentId', flag = 'id') {
  if (!Array.isArray(array)) {
    throw new Error('argument is not Array')
  }
  const obj = {}

  array.forEach((item) => {
    const parent = obj[item[parentFlag]]
    const child = obj[item[flag]]

    obj[item[flag]] = item
    if (child) {
      if (child[flag]) {
        throw new Error(`${flag} is not unique`)
      }
      obj[item[flag]].children = child.children
    }

    if (parent) {
      parent.children = parent.children || []
      parent.children.push(item)
    } else {
      obj[item[parentFlag]] = {
        children: []
      }
      obj[item[parentFlag]].children.push(item)
    }

    delete obj[item[flag]][parentFlag]
  })

  return obj
}

console.log(
  array2Tree([
    {
      id: 2,
      val: '班级1',
      parentId: 1
    },
    {
      id: 3,
      val: '班级2',
      parentId: 1
    },
    {
      id: 1,
      val: '学校',
      parentId: null
    },
    {
      id: 5,
      val: '学生2',
      parentId: 3
    },
    {
      id: 4,
      val: '学生1',
      parentId: 2
    },
    {
      id: 6,
      val: '学生3',
      parentId: 3
    }
  ])
)
```

### ES6 暂时性死区

1. 函数作用域

   在函数中声明的变量只能在函数内部访问。

2. 块级作用域（ES6）

   `{}` 内部就是一个块级作用域，块级作用域的概念只和 let/const 所声明的变量有关。

变量的声明的过程为

1. 创建
2. 初始化(undefined)
3. 赋值
   用 let 声明的变量，它的创建提升了，但是它的初始化没有提升。
   而用 var 声明的变量，它的创建和初始进行了提升

let 不允许在相同作用域内，重复声明同一个变量：

```js
// 报错
function func() {
  let a = 10
  var a = 1

// 报错
function func() {
  let a = 10
  let a = 1
}
```

```js
let a = 2
{
  console.log(a)
  var a = 1
}
//Identifier 'a' has already been declared
```

对于 var 声明的变量，是不存在块级作用域的，因此我们用 let 和 var 在全局执行环境中声明了 a 变量两次，从而报错。

for 循环有一个特别之处，就是设置循环变量的那部分是一个**父作用域**，而循环体内部是一个**单独的子作用域**。

```js
var arr = []
for (let i = 0; i < 10; i++) {
  arr[i] = function() {
    console.log(i)
  }
}
```

循环体内部（子作用域）在每一次循环执行的时候都会生成一个新的作用域。不同的子作用域内部接受传进来的不同的 i 值。这就是 let 解决循环闭包的原因。

暂时性死区就是由于，**let/const** 声明变量时没有变量提升所导致的。或者我们可以理解为，**在变量仅创建，还没有初始化之时就使用了变量**。

只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

```js
var tmp = 123

if (true) {
  tmp = 'abc' // ReferenceError: Cannot access 'tmp' before initialization
  let tmp
}
```

关于 ES6 函数默认值暂死区域：

```js
function bar(x = y, y = 2) {
  return [x, y]
}

bar()
// Uncaught ReferenceError: Cannot access 'y' before initialization

bar(undefined，3)
// Uncaught ReferenceError: Cannot access 'y' before initialization

bar(1，3)
// [1,3]
```

当调用 `bar` 时，如果未给 x 传参数(`undefined`)，那么 x 就会去取 y 的值。但此时 y 还未初始化，所以报错。约等于以下情况：

```js
let x = y //在这个区域，就是变量 y 的暂死区域，所以会导致程序抛错
let y = 2
```

[理解 es6 中的暂时性死区](https://blog.csdn.net/ganlubaba666/article/details/89792643)

### arguments 反应实参变化

```js
constfn1 = function(a = 7, b = 8, c = 9) {
  a = 10
  console.log(arguments)
}
constfn2 = function(a, b, c) {
  a = 10
  console.log(arguments)
}
fn1(1, 2, 3) //输出结果：[1,2,3]
fn2(1, 2, 3) //输出结果：[10,2,3]
```

**只有在非严格模式，不包含解构参数，rest 参数(...a))，以及默认值，arguments 对象中的值才会跟踪参数的值**。

### 具名函数表达式

NFE（Named function expression）是具名函数表达式，例如：`var a = function foo () {…}`，与之对应的是匿名函数表达式(Anonymous Function Expression)，例如：`var foo = function () {…}`。

具名函数有 2 个注意点：

1. 作为函数名的标识符只能从函数体内部访问，在函数外部访问不到 (IE9+)
2. 绑定为函数名的标识符不能再绑定为其它值，即该标识符绑定是不可更改的（immutable）

```js
var b = function a() {
  console.log(a) //[Function A]
  a = 1
  console.log(a) //[Function A]
}
console.log(a) //Uncaught ReferenceError: a is not defined
```

在 IIFE 中使用具名函数也是如此：

```js
;(function A() {
  console.log(A) //[Function A]
  A = 1
  console.log(window.A) //undefined
  console.log(A) //[Function A]

  B = 1 //没有用var，会被定义成全局变量
  console.log(B) //1
})()
```

在严格模式下，对具名函数重新重新赋值会报错：

```js
var a = 1
;(function a() {
  'use strict'
  a = 2
  console.log(a)
})()

// VM1059:4 Uncaught TypeError: Assignment to constant variable.
```

### Object.getPrototypeOf

Object.getPrototypeOf 是获取指定对象的原型。

Object.getPrototypeOf(Object) 不是 Object.prototype。

Object.getPrototypeOf(Object) 等于 Object._proto_ 等于 Function.prototype。

Object.prototype 表示以 Object 为构造函数创建出来实例的原型。

```js
var obj = new Object()
;(Object.prototype === Object.getPrototypeOf(obj)) === obj._proto_
```

### Object.is

Object 在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0 和-0，NaN 和 NaN。

与 === 运算也不相同。 === 运算符 (也包括 == 运算符) 将数字 -0 和 +0 视为相等 ，而将 Number.NaN 与 NaN 视为不相等.

### Array.reduce

- arr.reduce(callback[, initialValue])
  - reduce 接受两个参数, 一个回调, 一个初始值
  - 回调函数接受四个参数 previousValue, currentValue, currentIndex, array
  - 如果一个函数不传初始值，数组第一个组默认为初始值
  - 只有初始值不会执行回调
  - 需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown.

### Array.filter

Array.filter 的回调函数对于那些已经被删除或者从未被赋值的索引不会被调用。

```js
var arr = [0, 1]
arr[5] = 5
delete arr[0]

newArr = arr.filter(function(x) {
  return x === undefined
})
console.log(newArr.length)
// 2
```

arr 是一个稀疏数组，遍历时会跳过这些 `缝隙` 。

[稀疏数组与密集数组](https://www.cnblogs.com/ziyunfei/archive/2012/09/16/2687165.html)

### Array.sort()

```js
;[1, 2, 5, 10].sort()

// [1,10,2,5]
```

JavaScript 默认使用字典序(alphanumeric)来排序。即逐位比较。

10 和 2 ，第一位: 1 < 2，所以 10 < 2。

### eval

```js
function test() {
  var a = 1
  return function() {
    eval('')
  }
}
test()
```

变量 a 会被 GC 吗？

- 答案
  不会

- 解析
  因为 eval 会欺骗词法作用域，例如 function test(){eval("var a = 1"},创建了一个 a 变量，不确定 eval 是否对 a 进行了引用，所以为了保险，不对其进行优化。相对，try catch,with 也不会被回收，with 会创建新的作用域。

### 展开运算符

```js
let ydObject = { ...null, ...undefined }
console.log(ydObject)

// {}

let ydArray = [...null, ...undefined]
console.log(ydArray)

// object null is not iterable
```

在对象中使用展开运算符，如果后面不是对象，会自动转换为对象：

```js
let ydObject = { ...null, ...undefined }
let ydObject = { ...Object(null), ...Object(undefined) }
```

### 浮点运算

`0.1 + 0.2 = 0.30000000000000004`。为什么？

JavaScript 中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有 float 32 位单精度）。

64 位比特又可分为三个部分：

符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数
指数位 E：中间的 11 位存储指数（exponent），用来表示次方数
尾数位 M：最后的 52 位是尾数（mantissa），表示精度，超出的部分自动进一舍零

图片：

0.1 转成二进制表示为 `0.0001100110011001100(1100)`，`1.100110011001100(1100)x2^-4`，所以 `E=-4+1023=1019`；M 舍去首位的 1，得到 `1001100110011001100110011001100110011001100110011010`（52 位， 超出的部分自动进 1 舍 0）

0.2 的转换也是如此。

因为转换为 2 进制精度损失，0.1 和 0.2 相加自然不会等于 0.3。

[探寻 JavaScript 精度问题以及解决方案](https://juejin.im/post/6844903687010123790#heading-0)

[JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)

### String("A") 和 new String('A')

new String('A') 返回对象实例，String("A") 返回字符串，等于字面量创建字符。

同理 Date(0) 和 new Date(0)

### 数组的原型是数组，对象的原型是对象，函数的原型是函数

### 常用的 es6

### 树的深度优先遍历

```js
// 深度优先遍历
function treeDFS(node, cb) {
  const children = node.children

  if (!children.length) {
    return
  }
  for (let i = 0; i < children.length; i++) {
    cb(children[i])
    treeDFS(children[i], cb)
  }
  return
}

const obj = {}

function cb(node) {
  const tagName = node.tagName

  if (/^[SH]+/.test(tagName)) {
    obj[tagName] = obj[tagName] || 0
    obj[tagName]++
  }
}

treeDFS(document.body, cb)

console.log(obj)
```

### 最大整数

```js
var END = Math.pow(2, 53)
var START = END - 100
var count = 0
for (var i = START; i <= END; i++) {
  count++
}
console.log(count)
```

在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.

### 引用类型比较大小

```js
var a = [1, 2, 3],
  b = [1, 2, 3],
  c = [1, 2, 4]
a == b
a === b
a > c
a < c

// false, false, false, true
```

数组间比较大小可以近视看做：就是先比第一项谁大，相同再去比第二项。

### String.replace

```js
'1 2 3'.replace(/\d/g, parseInt)
```

答案："1 NaN 3"
解析：replace() 回调函数的四个参数:

1. 匹配项
2. 与模式中的子表达式匹配的字符串
3. 出现的位置
4. stringObject 本身 。

如果没有与子表达式匹配的项，第二参数为出现的位置.所以第一个参数是匹配项，第二个参数是位置

```js
parseInt('1', 0)
parseInt('2', 2) //2进制中不可能有2
parseInt('3', 4)
```

### 函数名字

```js
function f() {}
var parent = Object.getPrototypeOf(f)
f.name // ?
parent.name // ?
typeof eval(f.name) // ?
typeof eval(parent.name) //  ?

// "f", "", "function", "undefined"
```

- f 的函数名就是 f
- parent 是 f 原型对象的名字为"" ,
- 先计算 eval(f.name) 为 f,f 的数据类型是 function
- eval(parent.name) 为 undefined, "undefined"

### 连续比较

```js
;[1 < 2 < 3, 3 < 2 < 1]
//[true,true]
```

- 1 < 2 < 3 => true < 2
- 3 < 2 < 1 => false < 1

### 逗号操作符

- 使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示：
  var num1=1, num2=2, num3=3;
- 除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示：
  var num = (5, 1, 4, 8, 0); // num 的值为 0
  由于 0 是表达式中的最后一项，因此 num 的值就是 0。

### Number.isFinite & isFinite

```js
Number.isFinite('0') === isFinite('0')

Number.isFinite(0) === isFinite('0')

// false,true
```

Number.isFinite()检测有穷性的值，唯一和全局 isFinite()函数相比，这个方法不会强制将一个非数值的参数转换成数值，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 true。

### 包装对象

引用类型和包装对象的区别在于生存期
引用类型所创建的对象会一直存在于堆内存中，而基本包装对象只存在于一瞬间
当访问非构造函数创建的 String, Number, Boolean 的属性时，会临时创建它们的包装对象（构造函数创建）。

自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。

```js
var str = 'hello'
str.number = 10

//假设我们想给字符串添加一个属性number ，后台会有如下步骤
/*
  var str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象
  str.number = 10; // 2 通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存
  str =null; // 3 这个对象又被销毁
*/
alert(str.number)

//undefined  当执行到这一句的时候，因为基本类型本来没有属性，后台又会重新重复上面的步骤
/*
 var str = new String('hello'); // 1 找到基本包装对象，然后又新开辟一个内存，创建一个值为hello对象
 str.number = undefined   // 2 因为包装对象下面没有number这个属性，所以又会重新添加，因为没有值，所以值是未定 ;然后弹出结果
 str =null; // 3 这个对象又被销毁
*/
```

### 字符串不可变

在 js 中，字符串一旦被创建，其值不可变。

```js
const x = 'abc'
x[0] = 'hhh'

console.log(x)
// abc

// 相当于重新创建了一个字符串
// 原字符串未变，但失去引用，被 gc
x = 'ddd'
```

所以，所有有关字符串的方法都不会改变原字符串。

### 继承

### 节流防抖

```js
function throttle(fn, timeout = 20, fisrtExe = true) {
  if (typeof fn !== 'function') {
    throw new Error('argument(s) error')
  }
  let timer = null

  return function() {
    if (fisrtExe) {
      fn(arguments)
      fisrtExe = false
    }
    if (!timer) {
      timer = setTimeout(() => {
        fn(arguments)
        clearTimeout(timer)
      }, timeout)
    }
  }
}

function debounce(fn, timeout = 20, fisrtExe = true) {
  if (typeof fn !== 'function') {
    throw new Error('argument(s) error')
  }
  let timer = null

  return function() {
    if (fisrtExe) {
      fn(arguments)
      fisrtExe = false
    }
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn(arguments)
      clearTimeout(timer)
    }, timeout)
  }
}
```

## 原生 ajax 实现

1. 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象.
2. 创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息.
3. 设置响应 HTTP 请求状态变化的函数.
4. 发送 HTTP 请求.
5. 获取异步调用返回的数据.

在 AJAX 实际运行当中，对于访问 XMLHttpRequest（XHR）时并不是一次完成的，而是分别经历了多种状态后取得的结果，对于这种状态在 AJAX 中共有 5 种，分别是：
0 - (未初始化)还没有调用 send()方法
1 - (载入)已调用 send()方法，正在发送请求
2 - (载入完成)send()方法执行完成，
3 - (交互)正在解析响应内容
4 - (完成)响应内容解析完成，可以在客户端调用了
对于上面的状态，其中“0”状态是在定义后自动具有的状态值，而对于成功访问的状态（得到信息）我们大多数采用“4”进行判断。

```js
var Ajax = {
  get: function(url, fn) {
    // XMLHttpRequest对象用于在后台与服务器交换数据
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url, true)
    xhr.onreadystatechange = function() {
      // readyState == 4说明请求已完成
      if ((xhr.readyState == 4 && xhr.status == 200) || xhr.status == 304) {
        // 从服务器获得数据
        fn.call(this, xhr.responseText)
      }
    }
    xhr.send()
  },
  // datat应为'a=a1&b=b1'这种字符串格式，在jq里如果data为对象会自动将对象转成这种字符串格式
  post: function(url, data, fn) {
    var xhr = new XMLHttpRequest()
    xhr.open('POST', url, true)
    // 添加http头，发送信息至服务器时内容编码类型
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4 && (xhr.status == 200 || xhr.status == 304)) {
        fn.call(this, xhr.responseText)
      }
    }
    xhr.send(data)
  }
}
```

## 原生 jsonp

```js
function jsonp(obj) {
  //定义一个处理Jsonp返回数据的回调函数
  let name = `callback` + Math.floor(Math.random() * 10000)
  window[name] = function(object) {
    obj.success(JSON.parse(object))
  }
  var script = document.createElement('script')
  //组合请求URL
  script.src = obj.url + `?callback=${name}`
  for (key in obj.data) {
    script.src += '&' + key + '=' + obj.data[key]
  }

  script.onload = function(e) {
    e.currentTarget.remove()
    delete window[name]
  }
  script.onerror = function(e) {
    e.currentTarget.remove()
    delete window[name]
  }
  //将创建的新节点添加到BOM树上
  document.body.appendChild(script)
}

jsonp({
  url: 'http://localhost:8080/test',
  data: {
    name: '小明'
  },
  success: function(obj) {
    alert('性别' + obj.sex)
  }
})
```

## 原型

Object.prototype 位于最顶层

Function.prototype：

```js
Function.prototype.__proto__ === Object.prototype
```

Function：

```js
Function.__proto__ === Function.prototype
```

Object:

```js
Object.__proto__ === Function.prototype
```

Array:

```js
Array.__proto__ === Function.prototype

Array.prototype.__proto__ === Object.prototype
```

## Map Set WeakMap WeakSet

### 集合（Set）

ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。

Set 本身是一种构造函数，用来生成 Set 数据结构。

Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。

Set 是使用键对来存储的。

性能分析：

因为使用键对，所以查找和删除时，不需要遍历。

数组的查找需要遍历，删除(splice(index, 1))需要移动 index 后面元素位置。

对于新添加元素，Set 需要检查重复，数组(push)不需要。

1. Set 查找和删除都比数组块。
2. Set 添加比数组慢。

```js
let set = new Set([1, 2, 3, 3])
```

操作方法：

- add(value)：新增，相当于 array 里的 push。
- delete(value)：存在即删除集合中 value。
- has(value)：判断集合中是否存在 value。
- clear()：清空集合。

便利方法：遍历方法（遍历顺序为插入顺序）

- keys()：返回一个包含集合中所有键的迭代器。
- values()：返回一个包含集合中所有值得迭代器。
- entries()：返回一个包含 Set 对象中所有元素得键值对迭代器。
- forEach(callbackFn, thisArg)：用于对集合成员执行 callbackFn 操作，如果提供了 thisArg 参数，回调中的 this 会是这个参数，没有返回值。
- for...of

WeakSet 对象允许你将弱引用对象储存在一个集合中。

WeakSet 与 Set 的区别：

- WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以。
- WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素。

方法：

- add(value)：在 WeakSet 对象中添加一个元素 value。
- has(value)：判断 WeakSet 对象中是否包含 value。
- delete(value)：删除元素 value。

### 字典（Map）

是一组键值对的结构，具有极快的查找速度。

key 为任何类型的唯一值。

性能分析：

Map 的实现使用了 hash table。

1. Map 添加、查询速度都是高于 Object。
2. Map 删除和 Object 差不多。

其添加查询

```js
const m = new Map([[(a: 1)], [(b: 2)]])
const o = { p: 'haha' }
m.set(o, 'content')
```

操作方法：

- set(key, value)：向字典中添加新元素。
- get(key)：通过键查找特定的数值并返回。
- has(key)：判断字典中是否存在键 key。
- delete(key)：通过键 key 从字典中移除对应的数据。
- clear()：将这个字典中的所有元素删除。

遍历方法：

- Keys()：将字典中包含的所有键名以迭代器形式返回。
- values()：将字典中包含的所有数值以迭代器形式返回。
- entries()：返回所有成员的迭代器。
- forEach()：遍历字典的所有成员。
- for...of

~~Map api 共用了两个数组（一个存放 key,一个存放 value）。给 Map set 值时会同时将 key 和 value 添加到这两个数组的末尾。从而使得 key 和 value 的索引在两个数组中相对应。当从 Map 取值时，需要遍历所有的 key，然后使用索引从存储值的数组中检索出相应的 value。这个实现的缺点很大，首先是赋值和搜索的时间复杂度为 O(n)~~；其次是可能导致内存溢出，因为数组会一直保存每个键值引用，即便是引用早已离开作用域，垃圾回收器也无法回收这些内存。

WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。

注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。

WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的 key 则变成无效的），所以，WeakMap 的 key 是不可枚举的。

方法：

- has(key)：判断是否有 key 关联对象。
- get(key)：返回 key 关联对象（没有则则返回 undefined）。
- set(key, value)：设置一组 key 关联对象。
- delete(key)：移除 key 的关联对象。

### WeakMap 怎么做到弱引用

WeakMap 本质上没有使用任何东西去存储 key 和 value。它只是在 key 上设置了一个属性，其值为 value。获取也是从 key 上读取这个 value。这也是为什么 key 必须为对象的原因。

## 运算符优先级

[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

1. ()括号
2. .成员访问 ()函数调用 new
3. `...++ ...--`
4. ! ~ +.. -.. ++... --... typeof
5. `**`
6. `*` / %
7. `+` -
8. `>=` <= > <
9. == !==
10. & ^ | 位运算符
11. && || 逻辑运算符
12. a ? x : y 条件运算符
13. = op = 运算赋值

```js
let a = { n: 1 }
let b = a
a.x = a = { n: 2 }
console.log(a.x)
console.log(b)

// undefined
// { n : 2}
```

对象存储在堆中，a、b 只是存储对象在堆中的地址。

先执行 a.x，在原对象中查找属性。

a 赋值为新对象，再将新对象赋值给原对象的 x 属性。

b 指向原对象。

```js
var val = 'smtg'
console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing')

// Something
```

`+` 比三元运算有更高的优先级。

### new 符号优先级

new (带参数列表) 优先级 和 `.`、函数调用优先级一致，遵循从左到右

new (无参数列表) 优先级次于上面的，遵循从右到左

```js
function Foo() {
  this.name = 1
}

Foo.getName = function() {
  alert(3)
}
```

new Foo 和 new Foo()一致。
new Foo.name 根据优先级，会先执行 Foo.name，所以会报错。
new Foo.getName()，先执行 Foo.getName 得到一个函数，假设为 x，再执行 new x()。
new new Foo().getName()，同上，先执行 new Foo()，再执行.getName 获取到一个函数 x，再执行 new x()。

### typeof 和 `!`

```js
const name = 'TianTianUp'
console.log(!typeof name === 'string')
```

typeof 和 `!` 同优先级，从右到左，执行！typeof name 返回 false，再严格相等判断。

## Vue

### 虚拟 DOM 的优缺点

优点：

1. 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
2. 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
3. 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

缺点：

1. 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。比如 VScode 采用直接手动操作 DOM 的方式进行极端的性能优化

为什么操作 DOM 会影响 WEB 应用的性能？

DOM 是一个独立于语言的、用于操作 XML 和 HTML 文档的程序接口(API)。在浏览器中主要用于与 HTML 文档打交道，并且使用 DOM API 用来访问文档中的数据。
DOM 是个与 ES 语言无关的 API，它在浏览器中的接口却是用 JavaScript 来实现的，DOM 就成了现在 JS 编码中的重要部分。

[为什么操作 DOM 会影响网页性能？](https://www.cnblogs.com/padding1015/p/11405788.html)

正因为浏览器中通常把 DOM 和 ECMAScript 独立实现。使得二者相互独立，就像两座孤岛。所以每次链接、每次访问 DOM 都会消耗性能！！ 可以说操作 dom 是十分昂贵的！！

而虚拟 dom 就是用来模拟 dom 的一种数据结构，通过 diff 算法，找到两次虚拟 dom 之间的更改，然后统一修改 dom，可以最小化操作 dom。这也是为什么使用虚拟 dom 能提升性能。

但虚拟 dom 无法获得最优性能，首先是要创建虚拟 dom，然后去执行 diff 算法，最后去执行 dom 更改。例如你修改一个按钮的颜色，用虚拟 dom 和直接操作 dom 修改，怎么想都是直接操作效率更高。

所以，如果设计好的直接 dom 操作才是性能的最优解。

[别再说虚拟 DOM 快了，要被打脸的](https://www.jianshu.com/p/4bc2d4eb11af)

[vue 的双向绑定原理及实现](https://www.cnblogs.com/dillonmei/p/12570634.html)

[vue2.0 的 diff 算法详解](https://www.jianshu.com/p/92a7496af50c)

### hook

```js
mounted: function () {
  var picker = new Pikaday({
    field: this.$refs.input,
    format: 'YYYY-MM-DD'
  })

  // beforeDestroy 周期触发时，触发
  this.$once('hook:beforeDestroy', function () {
    picker.destroy()
  })
}
```

```js
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
}

//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},

// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...
```

### hash 和 history

hash 模式： **在浏览器中符号“#”，#以及#后面的字符称之为 hash**，用 window.location.hash 读取；

特点：**hash 虽然在 URL 中，但不被包括在 HTTP 请求中**；用来指导浏览器动作，对服务端安全无用，**hash 不会重加载页面**。

hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。

history 模式： history 采用 HTML5 的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及 popState 事件的监听到状态变更。

history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”

### 监听数组变动

为每个定义的数组使用 Object.defineProperty 重写 `push` 等方法。

### Vue 中 key 值的作用

key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

用于列表渲染和多元素过渡。

https://cloud.tencent.com/developer/article/1618239
https://www.jianshu.com/p/0044532e4a93

## CSS

### css 伪类与伪元素区别

- 伪类和伪元素都是⽤来表示⽂档树以外的"元素"。
- 伪类和伪元素分别⽤单冒号:和双冒号::来表示。
- 伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类。
- 伪类其实就是基于普通 DOM 元素⽽产⽣的不同状态，他是 DOM 元素的某⼀特征。
- 伪元素能够创建在 DOM 树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。

伪类表示抽象的类，它描述 dom 的特征，比如元素 :hover，元素的位置:first-child。

伪元素是创建了一个抽象节点，html 文档中本没有这个节点，这个节点表现为与普通节点一致，并且能够被访问到。

```js
var color = window
  .getComputedStyle(document.querySelector('.element'), ':before')
  .getPropertyValue('color')
```

### 垂直水平居中

### em

1. 子元素字体大小的 em 是相对于父元素字体大小
2. 元素的 width/height/padding/margin 用 em 的话是相对于该元素的 font-size

### 盒模型

盒模型的组成，由里向外 content,padding,border,margin.

在 IE 盒子模型中，width 表示 **content+padding+border** 这三个部分的宽度

在标准的盒子模型中，width 指 **content** 部分的宽度

```
box-sizing: content-box 是W3C盒子模型
box-sizing: border-box 是IE盒子模型
```

### css 画三角形、扇形

```css
.triangle {
  width: 0;
  height: 0;
  border-width: 100px;
  border-style: solid;
  border-color: transparent transparent #0099cc transparent;
}

.sector {
  width: 0;
  height: 0;
  border-width: 100px;
  border-style: solid;
  border-color: transparent transparent #0099cc transparent;
}
```

### 清除浮动

1. ::after + clear:both

   ```css
   .container::after {
     display: block;
     clear: both;
     content: '';
     overflow: hidden;
   }
   ```

2. BFC

   **BFC 的生成：**

   1. 根元素
   2. float 的值不为 none
   3. overflow 的值不为 visible
   4. display 的值为 inline-block、table-cell、table-caption，display：table 也认为可以生成 BFC，其实这里的主要原因在于 Table 会默认生成一个匿名的 table-cell，正是这个匿名的 table-cell 生成了 BFC
   5. position 的值为 absolute 或 fixed

   **BFC 的约束规则：**

   1. 内部的 Box 会在垂直方向上一个接一个的放置
   2. 垂直方向上的距离由 margin 决定。（完整的说法是：属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠（塌陷），与方向无关。）
   3. 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明 BFC 中子元素不会超出他的包含块，而 position 为 absolute 的元素可以超出他的包含块边界）
   4. BFC 的区域不会与 float 的元素区域重叠
   5. 计算 BFC 的高度时，浮动子元素也参与计算
   6. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然

### 三栏布局

### inline-block 中间间隙

行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔。

父元素 font-size:0。

### CSS3 新特性

- 支持媒体查询

  ```CSS
  @media not|only mediatype and (expressions) {
      CSS 代码...;
  }

  /* 例如 可视窗口大于480px时 同理 max-width*/
  @media screen and (min-width: 480px) {
      #leftsidebar {width: 200px; float: left;}
      #main {margin-left:216px;}
  }
  ```

  mediatype:all|printscreen|speech

- 文字阴影 text-shadow: 5px 5px 5px #ff0000;
- 盒阴影 box-shadow: 10px 10px 5px 3px #888888 outset
- 支持圆角 border-radius: 50%;

- transition
- animation
  animation: myfirst 5s linear 2s infinite|2|3(次数) reverse(反向播放)|alternate(动画在奇数次（1、3、5...）正向播放，在偶数次（2、4、6...）反向播放。)|alternate-reverse(动画在奇数次（1、3、5...）反向播放，在偶数次（2、4、6...）正向播放。);

- transform

- 新背景属性:

- background-image

- background-size: length|percentage|cover|contain

  - cover
    此时会保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小。(占满但可能显示不全)
  - contain
    此时会保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。（显示全但可能不占满）

- background-origin: padding-box|border-box|content-box
  背景图片的放置, 该属性指定了背景从哪个区域(边框、补白或内容)开始绘制

- background-clip: border-box|padding-box|content-box;
  背景图片的剪裁，该属性指定了背景在哪些区域(边框、补白或内容)可以显示

  ```css
  .div {
    background-origin: padding-box;
    background-clip: content-box;
  }
  ```

  这里表示背景图片从 padding 开始绘制，但只会显示 content 中的那部分。

- background-position [left top]|[x% y%]|[xpos ypos]
  设置背景图像的起始位置。
  背景图像左上角点在容器中的坐标。依赖于 background-origin 的设置。
  百分比含义：`(容器的宽度 — 背景图片的宽度) * x百分比`，所以 `center center`（`%50 %50` 总能让图片中心居中于容器）

### css 优先级

- 元素和伪元素：1
- 类选择器、属性选择器或伪类：10
- id 选择符：100
- 内联样式：1000
- !important 声明的样式优先级最高，如果冲突再进行计算。
- 继承得到的样式的优先级最低。
- 如果优先级相同，则选择最后出现的样式。

## HTML

### DOM 事件

三个事件级别，注意没有 DOM1，因为 DOM1 标准制定的时候没有涉及 DOM 事件。DOM3 比 DOM2 只是增加了一些事件类型。

- DOM0：element.onclick = function(){}
- DOM2：element.addEventListener('click', function(){}, false)
- DOM3：element.addEventListener('keyup', function(){}, false)

捕获的流程为：window -> document -> html -> body -> ... -> 目标元素。
冒泡的流程为：目标元素 -> ... -> body -> html -> document -> window。

1. event. preventDefault()
   取消事件的默认动作。

2. event.stopPropagation()
   阻止事件冒泡。

3. event.stopImmediatePropagation()
   阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他 的两个事件将不会被执行。

### HTML5 声明

```html
<!DOCTYPE html>
```

### display:none、visibility:hidden 和 opacity:0

1. 空间占据

   - display:none 隐藏后不占据额外空间，它会产生回流和重绘
   - visibility:hidden 和 opacity:0 元素虽然隐藏了，但它们仍然占据着空间，它们俩只会引起页面重绘。

2. 子元素继承

   - display:none 不会被子元素继承，但是父元素都不在了，子元素自然也就不会显示了，皮之不存，毛之安附~~
   - visibility:hidden 会被子元素继承，可以通过设置子元素 visibility:visible 使子元素显示出来
   - opacity: 0 也会被子元素继承，但是不能通过设置子元素 opacity: 0 使其重新显示

3. 事件绑定

   - display:none 的元素都已经不再页面存在了，因此肯定也无法触发它上面绑定的事件；
   - visibility:hidden 元素上绑定的事件也无法触发；
   - opacity: 0 元素上面绑定的事件是可以触发的。

4. 过渡动画

   - transition 对于 display 肯定是无效的，大家应该都知道；
   - transition 对于 visibility 有效，但只会延迟指定动画时间后，瞬间显示出来。
   - transition 对于 opacity 是有效，大家也是知道的。

### 浏览器渲染机制

## 安全

### CSRF

CSRF（Cross-site request forgery）跨站请求伪造。

#### 攻击原理

1. 用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；
2. 在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；
3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；
4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；
5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。

Cookie 是只要向对应服务器发送请求，浏览器就会自动附带，无关发送的网站。所以 C 网站发送请求给 A 网站，会附带 Cookie。

#### 防御措施

1. Token 验证
2. Referer 验证（简单易行，但 referer 可能被改变）
   HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址，在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站
3. 隐藏令牌（跟 Token 验证差不多，把令牌存到 header 中）
4. 可以设置 `Access-Control-Allow-Origin` 响应头来指定特定网站的跨域请求。

### XSS

XSS（cross-site scripting）跨域脚本攻击

#### 攻击原理

往 Web 页面里插入恶意 Script 代码，向服务端传输 html 格式字符，服务器再返回，页面再将这段 html 字符插入到网页，例如：`<script>alert('XSS');</script>`。这段字符浏览器会以标签形式解析这段字符。

### 防御措施

1. HTML：对以下这些字符进行转义：

   ```
   &：&amp;
   <：&alt;
   >：&gt;
   '：&#x27;
   "：&quot;
   /：&#x2F;
   ```

2. Javascript：把所有非字母、数字的字符都转义成小于 256 的 ASCII 字符；
3. URL：使用 Javascript 的 encodeURIComponent()方法对用户的输入进行编码，该方法会编码如下字符：`, / ? : @ & = + \$ #`

## 算法

### 洗牌算法

随机一张牌，与最后一张牌交换。再随机 0 ～倒数第二张牌 之间的一张牌与倒数第二张牌交换。

### 数组 n 数之和等于一个 sum

### 排序

```js
function bubble(array, desc = false) {
  if (!Array.isArray(array)) {
    throw new Error('argument(s) error')
  }

  for (let i = array.length - 1; i >= 0; i--) {
    // 数组最后一项为已经排好的数
    for (let j = 0; j < i; j++) {
      if (desc) {
        if (array[j] < array[j + 1]) {
          ;[array[j], array[j + 1]] = [array[j + 1], array[j]]
        }
      } else {
        if (array[j] > array[j + 1]) {
          ;[array[j], array[j + 1]] = [array[j + 1], array[j]]
        }
      }
    }
  }
  return array
}

function insertSort(array, desc = false) {
  if (!Array.isArray(array)) {
    throw new Error('argument(s) error')
  }

  for (let i = 1; i < array.length; i++) {
    const current = array[i]
    let index = 0

    for (let j = i - 1; j >= 0; j--) {
      if ((!desc && current < array[j]) || (desc && current > array[j])) {
        array[j + 1] = array[j]
      } else {
        index = j + 1
        break
      }
    }

    array[index] = current
  }
  return array
}

function selectSort(array, desc = false) {
  if (!Array.isArray(array)) {
    throw new Error('argument(s) error')
  }

  for (let i = 0; i < array.length - 1; i++) {
    let index = i

    for (let j = i + 1; j < array.length; j++) {
      if (
        (!desc && array[j] < array[index]) ||
        (desc && array[j] > array[index])
      ) {
        index = j
      }
    }

    ;[array[i], array[index]] = [array[index], array[i]]
  }

  return array
}
```

### 二分查找

```js
function binarySearch(array, value, sorted = false) {
  if (!Array.isArray(array)) {
    throw new Error('argument(s) error')
  }

  if (!sorted) {
    array.sort((a, b) => a - b)
  }

  let start = 0
  let end = array.length - 1

  while (start <= end) {
    // 中间索引
    const middle = Math.floor((end + start) / 2)

    if (value < array[middle]) {
      end = middle - 1
    } else if (value > array[middle]) {
      start = middle + 1
    } else {
      return middle
    }
  }

  return -1
}
```

### 判断回文字符串

```js
function palindromeStr(str) {
  const middle = Math.floor((str.length - 1) / 2)

  for (let i = 0; i <= middle; i++) {
    const start = i
    const end = str.length - 1 - i

    if (start === end) {
      break
    }

    if (str[start] !== str[end]) {
      return false
    }
  }

  return true
}
```

### 随机定长字符

```js
function randomStr(length = 10) {
  const array = []
  const asciiStart = 33
  const asciiEnd = 126

  for (let i = 0; i < length; i++) {
    array[i] = Math.floor(
      Math.random() * (asciiEnd - asciiStart + 1) + asciiStart
    )
  }

  return String.fromCharCode(...array)
}
```

### 全排列算法

#### 交换回溯法

例如：abc -> abc,acb,bac,bca,cab 和 cba。就是所学的排列，第一次从 3 个选取 1 个，第二次从 2 个选取 1 个，总排列种数：`3*2=6`。

算法描述：

循环遍历，先选取第一个不同位，再将剩下的（除第一位）的字符串再循环遍历，选取第二个不同位，继续同上至最后一个元素。递归思想。

例如 abc，选取第一位 abc 三个中的一个，假如是 a，再从 bc 中选取一个假如是 c，所得排列就是 acb。

如何选取：

循环遍历时，每次将第一位与其他位交换。如果出现重复就跳过重复的字符。

例如 abc，遍历到 0 索引时，选取的第一位就是 a，遍历到 1 索引时，将索引 0 的字符和索引 1 的字符交换，即：a 和 b 交换，选取到第一位就是 b。

需要注意的是每次交换后，需要再交换回去，不然排列出错。

```js
/**
 *
 * @param {Array|String} str 带排列的字符串或者数组
 * @param {Number} [str.length] 从中选取多少项排列
 */

function permutation(str, n = str.length) {
  const array = Array.isArray(str) ? str : str.split('')

  if (array.length === 0) {
    return []
  }

  const res = []
  const length = n

  function select(array, start, end, n) {
    if (n < 1) {
      res.push(array.slice(0, length).join(''))
      return ''
    }

    const selected = {}

    for (let i = start; i < end; i++) {
      // 去除重复的选择
      if (selected[array[i]]) {
        continue
      }
      selected[array[i]] = 1
      ;[array[start], array[i]] = [array[i], array[start]]
      select(array, start + 1, end, n - 1)
      ;[array[start], array[i]] = [array[i], array[start]]
    }
  }
  select(array, 0, array.length, n)
  return res
}

console.log(permutation('aabc'))
console.log(permutation('aabc', 2))
```

#### 字典序法

1. 从排列的右端开始，找出第一个比右边数字小的数字的序号 j（j 从左端开始计算），即 `j = max{i|pi<pi+1}`
2. 在 pj 的右边的数字中，找出所有比 pj 大的数中最小的数字 pk，即 `k = max{i|pi>pj}`（右边的数从右至左是递增的，因此 k 是所有大于 pj 的数字中序号最大者）
3. 对换 pi，pk
4. 再将 pj+1......pk-1pkpk+1......pn 倒转得到排列 p'=p1p2.....pj-1pjpn.....pk+1pkpk-1.....pj+1，这就是排列 p 的下一个排列。

证明见：

[全排列的实现方法--递归&字典序](https://blog.csdn.net/LaoJiu_/article/details/51115352?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)

```js
function permutationDictionary(str) {
  const array = Array.isArray(str) ? str : str.split('')

  if (array.length === 0) {
    return []
  }

  array.sort()

  const res = [array.concat().join('')]

  let i

  while (true) {
    for (i = array.length - 2; i >= 0; i--) {
      if (array[i] < array[i + 1]) {
        let index = 0

        for (let j = array.length - 1; j > i; j--) {
          if (array[j] > array[i]) {
            index = j
            break
          }
        }

        ;[array[i], array[index]] = [array[index], array[i]]

        for (let s = i + 1, e = array.length - 1; s < e; s++, e--) {
          ;[array[s], array[e]] = [array[e], array[s]]
        }
        res.push(array.concat().join(''))
        break
      }
    }
    // 没有发生交换，跳出while
    if (i < 0) {
      break
    }
  }

  return res
}

console.log(permutationDictionary('aabc'))
```

字典序法自动去重，但只能实现整体的全排列，而不能实现递归法的选择其中几个元素。

### 动态规划

#### 连续子数组的最大和

例如：`[6, -3, -2, 7, -15, 1, 2, 2]`，最大子数组为 `[6, -3, -2, 7]` 和为 8。

1. 状态定义：**dp[i]表示以 i 结尾的连续子数组的最大和**。所以最终要求 dp[n-1]
2. 状态转移方程：dp[i] = max(array[i], dp[i-1]+array[i])
3. 解释：如果当前元素为整数，并且 dp[i-1]为负数，那么当然结果就是只选当前元素

具体描述：

```js
dp[0] = 6
dp[1] = max(dp[0] + array[1], array[1])
dp[2] = max(dp[1] + array[2], array[2])
```

```js
function FindGreatestSumOfSubArray(array) {
  let dp = []
  let ret = (dp[0] = array[0])
  for (let i = 1; i < array.length; i++) {
    dp[i] = Math.max(dp[i - 1] + array[i], array[i])
    ret = Math.max(dp[i], ret)
  }
  return ret
}
```

#### 最大不重复子串

有一个字符串，现在让我们求出最大的不重复的连续的子串的长度，

例如：`abcabcbb` -> `abc`

1. 状态定义：**dp[i]表示以 i 结尾的最长连续子字符串**。
2. `dp[i]` 和 `dp[i-1]` 之间的关系：如果 `str[i]` 没有在 `dp[i-1]` 中出现，那 `dp[i]=dp[i-1]+str[i]`；如果出现了，假设出现的索引为 `dup`，那 `dp[i]` 的开始位置索引为 `start=dup+1`，即 `dp[i]=dp[i-1].substring(dup+1,dp[i].length)+str[i]`。

```js
function lengthOfLongestSubstring(str) {
  let maxStr = ''
  const dp = []

  dp[0] = str[0]
  maxStr = dp[0].length

  for (let i = 1; i < str.length; i++) {
    const index = dp[i - 1].indexOf(str[i])

    dp[i] = dp[i - 1].slice(index + 1) + str[i]
    maxStr = Math.max(maxStr, dp[i].length)
  }
  return maxStr
}
```

#### 最大回文字符串

1. 状态定义：**dp[i][j]表示子串[i...j]是否是回文字符串**。
2. 状态转移方程：`dp[i][j] = s[i]===s[j] && dp[i+1]dp[j-1]`；当 `j-i< 3` 时，`dp[i][j] = s[i]===s[j]`。
3. 初始：`dp[i][i] = true`。
4. 具体：循环字符串，得到 `j`，再依次判断 `[0...j] [1...j] ... [j-1...j]`（即：以 j 结尾的全部子字符串） 是否是回文字符串。这样可保证判断时 `[i...j]` 时，`[i+1...j-1]` 已经被判断了，因为 `j` 每向后移动一位，表示以 `j-1` 为尾的子字符串已经全部判断完毕。

```js
function longestPalindrome(str) {
  if (str.length === 0) {
    return
  }
  const dp = []
  let start = 0
  let end = 0

  for (let i = 0; i < str.length; i++) {
    dp[i] = []
    dp[i][i] = true
  }

  for (let j = 1; j < str.length; j++) {
    for (let i = 0; i < j; i++) {
      if (j - i < 3) {
        dp[i][j] = str[i] === str[j]
      } else {
        dp[i][j] = str[i] === str[j] && dp[i + 1][j - 1]
      }

      if (dp[i][j] && j - i > end - start) {
        start = i
        end = j
      }
    }
  }

  return str.slice(start, end + 1)
}
```

其他方法查看：[力扣面试题学习](https://blog.nowcoder.net/n/a7da88ae059d4708a5e93005fabe8836)

#### 背包问题

0-1 背包

题目：有一个容量为 c 的背包，和一些物品。这些物品分别有两个属性，体积 w 和价值 v，每种物品只有一个。要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。

1. 状态定义：**`dp[i][j]` 表示背包容量为 `j` 时，放入前 `i` 个物品时的最大价值**。
2. 对于一个物品，只有放与不放两种情况。如果不放，那 `dp[i][j]=dp[i-1][j]`；如果放，必须保证的是这个背包剩余的空间足够放下该物品，先为物品留出空间，求解留出空间后的背包在 `i-1` 个物品下能获取的最大价值 `dp[i-1][j-w[i]]`，再加上当前物品的价值，`dp[i-1][j-w[i]]+v[i]`。
3. 举例说明：
   这里的主体是物品，也就是说要确定**当前物品被放进去时，能产生的最大价值**。
   假设求 `dp[3][10]`：
   - 现在 w=5 的物品放进去，在容量为 10 下能产生的最大价值： `dp[2][5]`的值加上新物品的价值，假设为 `F`。
   - 但 `F` 可能并不是 `dp[3][10]`（表示的是容量为 10，放入前 3 个物品时最大价值），所以还需要与 `dp[2][10]` 比较。
   - 在状态定义中，描述的是 **前 `i` 个物品**，如果背包剩余空间足够， w=5 放进去，前 2 个物品还在，`F` 就是`dp[3][10]`；如果背包的剩余空间不足够，那自然是先放 w=5 的物品，在根据剩余空间放其他 2 个物品中的 1 个或是 0 个，这时就需要和原先的 `dp[2][10]` 比较了。
4. 状态转移方程，还需要考虑背包的容量是大于当前物品体积。

   - `j<w[i]，dp[i][j] = dp[i-1][j]`，背包装不下该物品，最大价值不变
   - `j>=w[i], dp[i][j] = max(dp[i-1][j-w[i]] + v[i], dp[i-1][j])`

```js
function backpackZeroOne(c, w, v) {
  if (v.length !== w.length) {
    return 0
  }

  const nums = v.length
  const dp = []

  dp[0] = []
  for (let i = 0; i <= c; i++) {
    // 初始放入0个物品，价值为0
    dp[0][i] = 0
  }

  // dp[0] = []
  // dp[0][0] = 0
  // for (let i = 1; i <= c; i++) {
  //   // 初始放入0个物品，价值为0
  //   dp[0][i] = Number.NEGATIVE_INFINITY
  // }

  for (let i = 0; i < nums; i++) {
    // index表示第几个物品，索引从0开始，加1
    const index = i + 1

    dp[index] = []
    for (let j = 0; j <= c; j++) {
      if (j >= w[i]) {
        dp[index][j] = Math.max(
          dp[index - 1][j],
          dp[index - 1][j - w[i]] + v[i]
        )
      } else {
        dp[index][j] = dp[index - 1][j]
      }
    }
  }

  return dp[nums][c]
}

console.log(backpackZeroOne(5, [1, 2, 3], [5, 2, 8]))
```

变式：要求恰好装满背包时，把 `dp[0][0]`设为 0，其余 `dp[0][j]` 设为负无穷即可，这样只有恰好达到 dp[n][c]时，dp[n][c] 才为正值。

[动态规划-背包问题](https://www.cnblogs.com/yun-an/p/11037618.html)
[背包问题](https://blog.nowcoder.net/n/0917813a51f84915b1706d9347451a80)

完全背包

完全背包条件和上面一样，只是每个物品的数量无限个。

思路和上面一样，只是每个物品可以放多个，即：`dp[i-1][j - k*w[i]] + k*v[i]`。`k` 表示可以放多个同类物品。

```js
function backpackFull(c, w, v) {
  if (v.length !== w.length) {
    return 0
  }

  const nums = v.length
  const dp = []

  dp[0] = []
  for (let i = 0; i <= c; i++) {
    // 初始放入0个物品，价值为0
    dp[0][i] = 0
  }

  for (let i = 0; i < nums; i++) {
    // index表示第几个物品，索引从0开始，加1
    const index = i + 1

    dp[index] = []
    for (let j = 0; j <= c; j++) {
      // 初始化为0
      dp[index][j] = 0
      // 循环依次放入 k 个当前物品
      for (let k = 0; k <= j; k++) {
        // 当 k 个物品体积和大于背包体积时，跳出循环
        if (k * w[i] > j) {
          break
        }
        // 取每次最大值
        dp[index][j] = Math.max(
          dp[index][j],
          dp[index - 1][j - k * w[i]] + k * v[i]
        )
      }
    }
  }

  return dp[nums][c]
}

console.log(backpackFull(4, [1, 2, 3], [5, 11, 8]))
```

### 滑动窗口法

## 进程和线程

## 编程

### bind 实现

```js
function bind(fn, context) {
  if (typeof fn !== 'function') {
    throw new Error('argument(s) error')
  }

  const params = [].slice.call(arguments, 2)

  return function() {
    fn.call(context, ...params)
  }
}
```

### 前端路由

#### hash 模式

- 原理:

  在 url 中的 # 之后对应的是 hash 值, 其原理是通过 hashChange() 事件监听 hash 值的变化, 根据路由表对应的 hash 值来判断加载对应的路由加载对应的组件

- 优点:

  1. 只需要前端配置路由表, 不需要后端的参与
  2. 兼容性好, 浏览器都能支持
  3. hash 值改变不会向后端发送请求, 完全属于前端路由

- 缺点:

  1. hash 值前面需要加#, 不符合 url 规范,也不美观

```js
function Router() {
  this.routes = {}
}

Router.prototype.add = function(path, callback) {
  this.routes[path] = callback || function() {}
}

Router.prototype.push = function(path) {
  location.hash = path
}

Router.prototype.init = function() {
  const hashChange = () => {
    const currentUrl = location.hash.slice(1) || '/'

    this.routes[currentUrl] && this.routes[currentUrl]()
  }

  // 第一次进入页面时
  window.addEventListener('load', hashChange, false)
  window.addEventListener('hashchange', hashChange, false)
}

const router = new Router()

router.init()
router.add('/home', () => {
  console.log('this is home page')
})
router.push('/home')
```

#### history 模式

- 原理:

  利用 pushState() 和 replaceState() 方法，onpopState 监听浏览器前进后退

- 优点:

  1. 符合 url 地址规范, 不需要#, 使用起来比较美观

- 缺点:

  1. 在用户手动输入地址或刷新页面时会发起 url 请求, 后端需要配置 index.html 页面用户匹配不到静态资源的情况, 否则会出现 404 错误
  2. 兼容性比较差, 是利用了 HTML5 History 对象中新增的 pushState() 和 replaceState() 方法,需要特定浏览器的支持.

```js
function Router() {
  this.routes = {}
}

Router.prototype.add = function(path, callback) {
  this.routes[path] = callback || function() {}
}

Router.prototype.push = function(path) {
  // 可以通过 history.state 读取
  const state = {
    route: path
  }

  history.pushState(state, null, path)
  this.routes[path] && this.routes[path]()
}

Router.prototype.init = function() {
  const pathChange = (e) => {
    console.log(e.state)

    const path = location.pathname

    this.routes[path] && this.routes[path]()
  }

  // 第一次进入页面时
  window.addEventListener('load', pathChange, false)
  window.addEventListener('popstate', pathChange, false)
}

const router = new Router()

router.init()
router.add('/home', () => {
  console.log('this is home page')
})
router.push('/home')
```

## 数据结构

https://cloud.tencent.com/developer/ask/112047

### 队列

队列（queue）是只允许在**一端进行插入操作**，而在**另一端进行删除操作**的线性表。

队列是一种**先进先出**（First in First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。

### 二叉树

https://blog.csdn.net/qq_36903042/article/details/100798101

### 链表

链表的插入删除时间复杂度时 O(1)，查询的时间复杂度为 O(n)。
但链表在插入删除时，需要遍历找到插入的节点，这样它时间复杂度还是 O(n)。
如果已经知道节点，那插入的时间复杂度 O(1)。

双链表：每个节点有 next 和 pre 两个指针。

循环链表：尾节点的 next 指向头节点，即 `tail.next=head`。

```js
class Node {
  constructor(value, next, pre) {
    this.value = value
    this.next = next
    this.pre = pre
  }
}

class LinkedList {
  constructor() {
    this.head = null
    this.tail = null
  }

  append(value) {
    const node = new Node(value)

    if (this.head) {
      node.next = this.head
      this.head = node
    } else {
      this.head = node
    }
  }

  getIndex(value) {
    let index = 0
    let node = this.head

    while (node) {
      if (node.value === value) {
        return index
      }
      node = node.next
      index++
    }
    return -1
  }

  findByValue(value) {
    let node = this.head

    while (node) {
      if (node.value === value) {
        return node
      }
      node = node.next
    }
    return null
  }

  findByIndex(index) {
    let currentIndex = 0
    let node = this.head

    while (node) {
      if (currentIndex === index) {
        return node
      }
      node = node.next
      currentIndex++
    }
    return null
  }

  findPreNode(value) {
    let node = this.head

    while (node && node.next) {
      if (node.next.value === value) {
        return node
      }
      node = node.next
    }
    return null
  }

  insert(value, newValue) {
    const node = this.findByValue(value)

    if (node) {
      const newNode = new Node(newValue)

      newNode.next = node.next
      node.next = newNode
    }
  }

  remove(value) {
    const preNode = this.findPreNode(value)

    if (this.head.value === value) {
      this.clear()
    }

    if (preNode) {
      preNode.next = preNode.next.next
    }
  }

  size() {
    let size = 0
    let node = this.head

    while (node) {
      size++
      node = node.next
    }
    return size
  }

  clear() {
    this.head = null
  }
}

const list = new LinkedList()

list.append('a')
console.log(list)
list.append('b')
console.log(list)
list.insert('a', 'c')
console.log(list)
list.insert('c', 'd')
console.log(list)
list.remove('a')
console.log(list)
list.remove('b')
console.log(list)
```

## 发布订阅（事件分发）和 观察者

发布订阅比观察者多了一个调度中心。

https://segmentfault.com/a/1190000018706349

## 前端通用组件

单一职责

细粒度，恰到好处，可以被多处复用

通用性，足够的可定制空间

https://juejin.im/post/6844903847874265101#heading-4

移动端：

软键盘弹出，导致 fixed 定位的元素遮挡按钮。

监听`resize`或者输入框`focus`事件，改变遮挡按钮的位置。
https://blog.csdn.net/qq_33834489/article/details/80450950

click 事件和 touch 事件冲突

touch 事件和页面滑动（上下滑动，顶部下滑刷新）冲突

## webpack

优化构建和打包：

https://github.com/lgwebdream/FE-Interview/issues/25

## 主题切换

https://www.jianshu.com/p/35e0581629d2

## 前端架构

目录结构

公共资源（组件、配置、函数、样式、接口、图片字体、状态管理等）

中间件（接口拦截、路由拦截、权限管理、数据注入等）

代码规范——eslint

提交规范

测试

http://www.h-camel.com/show/1787.html
