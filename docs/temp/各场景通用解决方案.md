## 请求加密

仿造 `http` 原理，采用对称加密和非对称加密结合。

1. 前端持有 **非对称加密公钥**，然后生成 **对称加密密钥** （随机生成）。
2. 前端用 **非对称加密公钥** 加密 **对称加密密钥**，再传送给服务端。
3. 服务端用 **非对称加密私钥** 解密这个 **对称加密密钥** 。
4. 这样前端和服务端都持有 **对称加密密钥** ，可以愉快进行加密通信了。

但在这种情况下，服务端可能会存储过多 **对称加密密钥** ，所以应该是前端每次请求都带上这个被公钥加密的 **对称加密密钥**，服务端不去做存储。

接下来，要考虑几个问题：

1. **对称加密密钥** 是否需要过期，怎么去管理过期？

    如果要过期，前端不能通过 `Date` + 本地缓存去管理过期时间，这并不准确。
    可以和 `token` 结合，当 `token` 过期后，就重新生成 **对称加密密钥** 。

2. 可以关闭加密来面对可能发生的意外情况。

    应用开始时（或登录时），获取到加密配置，来决定接下来的请求是否需要加密。
    加密配置应该只对前端生效：假设配置本身是不加密，但此时更改为需要加密，那对于已经在运行的应用来说，因为没有获取新配置，还是会请求不加密。
    所以，对于后端来说，只要有 **对称加密密钥** 送过来且请求字段被加密，就需要去解密。如果请求字段没有加密，就正常流程。

3. 前端有版本，存量用户适配。

    同上，对于后端来说，只要有 **对称加密密钥** 送过来且请求字段被加密，就需要去解密。如果请求字段没有加密，就正常流程。

## token 验证

### 有状态 token

有状态 `token`，`token` 的过期时间保存在服务器上。

#### 更新 token 过期时间

**每一次请求，服务器都可以延长这些 `token` 的过期时间。**

如果这些 `token` 的过期时间被持久化到数据库或文件中，那么每次都去读取存储这些 `token` 将会代价昂贵，所以这些 `token` 的过期时间应该保存在缓存或者内存中。

如果存在多个服务器，一个服务器上保存的 `token` 信息对于另一个服务器来说是无法知道的，所以这些 `token` 信息应该集中保存在一个缓存服务器上。

这里的机制已经和 `session` 一致，服务端产生一个标识用户的 `sessionid` ，客户端保存这个 `sessionid` 在 `cookie` 中。

使用这种方式会存在以下一些问题：

1. 负责存储 `token` 的服务器挂掉或者重启，所有 `token` 都会丢失。

    这里应该有多台存储 `token` 的服务器作负载均衡。同时还需定期的将 `token` 信息持久化，这样即使所有服务器挂掉，也只是损失一段时间内的 `token` 信息。

2. 难以扩容，新增一台 `token` 服务器需要复制现有的所有 `token` 信息。
3. 所有的请求都将到 `token` 服务器中鉴权和查询过期时间，对 `token` 服务器压力过大。

#### 未过期的旧 token

当 `token` 被刷新时：

1. 未过期的旧 `token` 无效，服务端直接删除对应 `token` 。
2. 未过期的旧 `token` 保留一个短暂的有效时间，服务端更新 `token` 的过期时间。

### 无状态 `token`

`token` 的过期时间保存在 `token` 上，服务器不需要保存 `token` 的任何信息，只需认证传来的 `token` 是否是其签发以及根据 `token` 上附加的过期时间判断 `token` 是否过期。

#### 更新 token 过期时间

服务端提供一个 `refresh token` ，当 `token` 过期时，客户端凭借 `refresh token` 去获取新的 `token` 和新的 `refresh token`。

`refresh token` 的过期时间比 `token` 长，当 `refresh token` 也过期时，就需要跳去登录页重新登录了。

使用 `refresh token` 是为了给用户更长一段时间内提供静默登录的能力，从而更大程度减少用户在使用时突然出现的登录过期的情况。

当然也有其他不使用 `refresh token` 的刷新策略，例如：

1. 请求到来时，如果 `token` 的过期时间只剩 `2` 小时，就返回给客户端新的 `token`，
2. 即使 `token` 过期，但只要没有超过一定时间，就可以凭借这个过期的 `token` 去换取新 `token` 。

#### 未过期的旧 token

当 `token` 被刷新时，未过期的旧 `token` 应该无效（或者保留一个短暂的有效时间），所以服务器依旧需要去保存那些未过期的旧 `token` 。

如果服务端要保存这些未过期的旧 `token` ，那还是需要**单独的 `token` 服务器去存储**。

## 接口请求

通用的请求封装如下：

![](https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/%E9%80%9A%E7%94%A8%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/%E9%80%9A%E7%94%A8%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85.png)

### 拦截器

#### 请求拦截器

在请求拦截器中，可以做以下一些事情：

1. 添加一些通用参数，例如 `token`。
2. 添加通用请求地址前缀。
3. 开启请求过程中的 `loading`。
4. 加密。
5. 其他等等。

#### 响应拦截器

在响应拦截器中，可以做以下一些事情：

1. 格式化返回数据。
2. 保存 `token`。
3. `401` 时重新获取 `token` 或引导去重新登录。
4. 处理错误码，配置通用错误提示。
5. 其他等等

以 `axios` 为例：

```js
// 请求拦截器
axios.interceptors.request.use(
    function (config) {
        let { $encrypt, $tips } = config;

        if ($encrypt) {
            // 加密
        }

        if ($tips) {
            // 显示请求loading
        }

        // 附带token

        return config;
    },
    function (error) {
        return Promise.reject(error);
    }
);

// 响应拦截器
axios.interceptors.response.use(
    function (response) {
        let {
            // 请求时的配置信息
            config: { $showError },
            data
        } = response;

        let { code } = data;

        // 业务状态码不正确
        if (code !== 0 && $showError) {
            // 显示错误信息

            return Promise.reject(response);
        }

        return response;
    },
    function (error) {
        const res = error.response;

        // 身份验证失败
        if (res.status === 401) {
            // 前往登录页
        }

        return Promise.reject(error);
    }
);
```

### code 码

这里分为两类， `http` 请求状态码和业务状态码：

1. `http` 请求状态码，例如： `200`, `401`, `500` 等等
2. 业务状态码描述的订单状态，例如：交易成功，交易失败，交易进行中，当有业务状态码时， http 请求一般是成功（ `200` ）的。

在 **响应拦截器** 中，对 `code` 码做一些通用处理：

1. `http` 请求状态码和业务状态码不对时，返回 `rejected` 的 `promise`
2. 通用错误码映射和提示。
3. `401` 时重新获取 `token` 或引导去重新登录

### 接口映射

将请求地址映射为函数：

```js
// Get /service/user => fetchUserInfo
function fetchUserInfo(params, options) {
    return request('/service/user', { params, method: 'get', ...options });
}
```

而非直接在代码中调用 `request('/service/user')` 。

这么做的原因：

1. 对单个请求进行更多自定义配置，例如：从全局变量里取数据，自定义 `header` 等
2. 函数名更有语义化

### 并发竞态

在一个请求还未完成前，就发起相同的请求，因为网络原因，并不一定会按请求发起的顺序返回，这可能会造成数据混乱。

例如：有两个按钮 `A`, `B` ， `A` 按钮点击获取小明的信息并显示， `B` 按钮点击获取小红的信息并显示。获取信息的接口都是同一个接口，只是传参不同，我们很容易想到封装一个函数去获取用户信息并显示：

```js
async function showUserInfo(id) {
    // 根据 id 获取用户信息
    let user = await fetchUserInfo({ id });

    // 在页面上渲染用户信息
    render(user);
}

// 点击按钮获取用户信息，并渲染在页面上
btnA.onclick = () => showUserInfo(1);
btnB.onclick = () => showUserInfo(2);
```

当快速点击 `A`, `B` 按钮时，最终页面上渲染的用户信息可能和最后点击的按钮并不一致，例如：最后点击了 `B` 按钮，但渲染的小明的信息。

处理这样的竞态需要在每次请求前，**取消掉前面还没完成的相同请求**，

不同场景会有不同的差异，总结下来可分为以下 `2` 种情景：

1. 第一次之后的请求不执行，但返回第一次请求的结果
2. 第一次之后的请求执行，前面的请求取消

处理上述 `2` 种场景最好通过一个类来实现：

```js
class AxiosRace {
    #preCancelTokenSource = null;
    #firstRequest = null;
    hasFirstRequest = false;

    /**
     * @param {Object} options - 配置项。
     * @param {Boolean} options.cancelBefore - 取消之前的请求，只有最后一个请求有效。
     * @param {Boolean} options.blockAfter - 后面的请求不执行，并返回第一个请求的结果。
     */
    constructor(options) {
        const { blockAfter, cancelBefore } = options;

        if (cancelBefore) {
            this.request = this.#requestCancelBefore;
            return;
        }

        if (blockAfter) {
            this.request = this.#requestBlockAfter;
            return;
        }

        throw new Error('please provide the correct options');
    }

    // 取消之前的请求，只有最后一个请求有效
    #requestCancelBefore(url, config) {
        const axiosConfig = {
            ...config
        };

        // 取消上一次请求
        if (this.#preCancelTokenSource) {
            this.#preCancelTokenSource.cancel();
        }

        // 创建 cancel token
        const source = CancelToken.source();

        axiosConfig.cancelToken = source.token;
        axiosConfig.url = url;

        // 存储 cancel token
        this.#preCancelTokenSource = source;

        return axios.request(axiosConfig).finally(() => {
            this.#preCancelTokenSource = null;
        });
    }

    // 后面的请求不执行，并返回第一个请求的结果
    #requestBlockAfter(url, config) {
        // 返回第一次请求的结果
        if (this.#firstRequest) {
            return this.#firstRequest;
        }

        const axiosConfig = {
            ...config
        };

        axiosConfig.url = url;

        this.#firstRequest = axios.request(axiosConfig).finally(() => {
            this.#firstRequest = null;
            this.hasFirstRequest = false;
        });
        this.hasFirstRequest = true;

        return this.#firstRequest;
    }
}
```

### token 刷新

有些时候请求失败需要重新发起请求，例如：在 `401` 时重新获取 `token` 后，需要重新发起上次的请求。

在响应拦截器中实现：

```js
// 响应拦截器
axios.interceptors.response.use(
    function (response) {
        return response;
    },
    async function (error) {
        const res = error.response;

        // 身份验证失败
        if (res.status === 401) {
            // 获取新token
            await refreshToken();

            // 重新发起请求
            return axios.request(res.config);
        }

        return Promise.reject(error);
    }
);
```

在这里需要考虑并发的情况，多个请求都返回 `401` ，那这里就会刷新多次 `token` ，那先刷新 `token` 后重发的请求可能就会继续 `401`。

用上面 **竞态** 场景封装的类处理刷新 `token` ：

```js
let axiosRace = new AxiosRace({ blockAfter: true });

let refresh = (res) => {
    let { token } = res.data;
    localStorage.setItem('token', token);
};

let refreshToken = async () => {
    let res;

    // 竞态请求
    res = await axiosRace.request('/service/refresh_token');

    // 只在第一次时执行 refresh 函数，避免多次执行 refresh 函数
    if (axiosRace.hasFirstRequest) {
        return;
    }

    refresh(res);
};
```
