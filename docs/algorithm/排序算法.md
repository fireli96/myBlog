---
meta:
    - title: 排序法
      time: 2020-10-03 15:44:26
      tag: 算法,排序
---

# 排序算法

## 归并排序

将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。

通过递归的方式将大的数组一直分割，直到数组的大小为 `1` ，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为 `1` 的合并成一个大小为 `2` 的，再把两个大小为 `2` 的合并成 `4` 的 `......` 直到全部小的数组合并起来。

> 特性：时间复杂度：`O(nlogn)` ；空间复杂度：`O(n)` ；3、稳定排序 ；4、非原地排序

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {
    sort(nums, 0, nums.length - 1);
    return nums;
};

function sort(nums, start, end) {
    if (start === end) {
        return;
    }
    let mid = Math.floor((start + end) / 2);

    sort(nums, start, mid);
    sort(nums, mid + 1, end);
    merge(nums, start, end, mid);
}

function merge(nums, start, end, mid) {
    let i = start;
    let j = mid + 1;
    let temps = [];
    while (i <= mid && j <= end) {
        if (nums[i] < nums[j]) {
            temps.push(nums[i]);
            i++;
        } else {
            temps.push(nums[j]);
            j++;
        }
    }

    while (i <= mid) {
        temps.push(nums[i]);
        i++;
    }

    while (j <= end) {
        temps.push(nums[j]);
        j++;
    }

    for (let k = 0; k < temps.length; k++) {
        nums[start + k] = temps[k];
    }
}
```

可以发现，实现归并排序的原理如下：以递归后序遍历的方式平均分割数组，直到当前区间元素个数为 `1` 。为什么是后序遍历，后序遍历是左右根的顺序，在当前区间 **中点** 的左边为左子区间，右边为右子区间，当需要排序这个区间时，其左子区间和右子区间一定是已经排序好的，合并已排序好的左右子区间。

## 参考

1. [十大经典排序算法](https://www.cnblogs.com/itsharehome/p/11058010.html)
