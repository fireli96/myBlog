<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>拖拽排序 | Spark</title>
    <meta name="generator" content="VuePress 1.5.2">
    <script src="https://cdn.jsdelivr.net/gh/sparklinm/js-library/d/bundle.umd.js"></script>
    <link rel="icon" href="/logo.png">
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@11.0.0/dist/markdown-it.js"></script>
    <meta name="description" content="Just playing around">
    <meta title="拖拽排序" time="2020-6-15 10:3:30" tag="js,拖拽">
    <link rel="preload" href="/assets/css/0.styles.0c2811eb.css" as="style"><link rel="preload" href="/assets/js/app.61190595.js" as="script"><link rel="preload" href="/assets/js/32.6e130523.js" as="script"><link rel="prefetch" href="/assets/js/10.2414efa1.js"><link rel="prefetch" href="/assets/js/11.06130b25.js"><link rel="prefetch" href="/assets/js/12.33bbb473.js"><link rel="prefetch" href="/assets/js/13.b1db4ecb.js"><link rel="prefetch" href="/assets/js/14.f777e5f5.js"><link rel="prefetch" href="/assets/js/15.25bcc4f3.js"><link rel="prefetch" href="/assets/js/16.96bc9df6.js"><link rel="prefetch" href="/assets/js/17.b28d9c78.js"><link rel="prefetch" href="/assets/js/18.b0cb2472.js"><link rel="prefetch" href="/assets/js/19.5236e7cb.js"><link rel="prefetch" href="/assets/js/20.9b39d48b.js"><link rel="prefetch" href="/assets/js/21.413d7e5c.js"><link rel="prefetch" href="/assets/js/22.9b4b5648.js"><link rel="prefetch" href="/assets/js/23.429db586.js"><link rel="prefetch" href="/assets/js/24.a4b2bf53.js"><link rel="prefetch" href="/assets/js/25.da7f6f44.js"><link rel="prefetch" href="/assets/js/26.1c86c8c4.js"><link rel="prefetch" href="/assets/js/27.567853cd.js"><link rel="prefetch" href="/assets/js/28.e79e9272.js"><link rel="prefetch" href="/assets/js/29.4c76ffad.js"><link rel="prefetch" href="/assets/js/3.ff140cd7.js"><link rel="prefetch" href="/assets/js/30.024d7314.js"><link rel="prefetch" href="/assets/js/31.33031f17.js"><link rel="prefetch" href="/assets/js/33.58b44621.js"><link rel="prefetch" href="/assets/js/34.7400e94e.js"><link rel="prefetch" href="/assets/js/35.f2767470.js"><link rel="prefetch" href="/assets/js/36.0c59cfbe.js"><link rel="prefetch" href="/assets/js/37.d2c43d60.js"><link rel="prefetch" href="/assets/js/38.27af19fa.js"><link rel="prefetch" href="/assets/js/39.80642131.js"><link rel="prefetch" href="/assets/js/4.754dfb46.js"><link rel="prefetch" href="/assets/js/40.08f6c317.js"><link rel="prefetch" href="/assets/js/41.1f789247.js"><link rel="prefetch" href="/assets/js/42.22aa889a.js"><link rel="prefetch" href="/assets/js/43.ce3ab661.js"><link rel="prefetch" href="/assets/js/44.1a0e84c4.js"><link rel="prefetch" href="/assets/js/45.362e5ef5.js"><link rel="prefetch" href="/assets/js/46.4d738550.js"><link rel="prefetch" href="/assets/js/47.07a89f4e.js"><link rel="prefetch" href="/assets/js/48.c5699e18.js"><link rel="prefetch" href="/assets/js/49.7cdcb266.js"><link rel="prefetch" href="/assets/js/5.9db707e5.js"><link rel="prefetch" href="/assets/js/50.caaed377.js"><link rel="prefetch" href="/assets/js/51.c8eb298c.js"><link rel="prefetch" href="/assets/js/52.97badafd.js"><link rel="prefetch" href="/assets/js/53.7a9e10fc.js"><link rel="prefetch" href="/assets/js/54.273c8ea9.js"><link rel="prefetch" href="/assets/js/6.a3a6a4b1.js"><link rel="prefetch" href="/assets/js/7.ec11f840.js"><link rel="prefetch" href="/assets/js/8.86b5445f.js"><link rel="prefetch" href="/assets/js/9.c2af3ea8.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.46847213.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0c2811eb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="navbar-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Spark" class="logo"> <span class="site-name can-hide">Spark</span></a> <div class="links" style="max-width:nullpx;"><nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/web/" class="nav-link">
  Web开发
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  工具使用
</a></div><div class="nav-item"><a href="/docs/" class="nav-link">
  微代码
</a></div><div class="nav-item"><a href="/tag/" class="nav-link">
  云标签
</a></div> <!----></nav> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></header></div> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/web/" class="nav-link">
  Web开发
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  工具使用
</a></div><div class="nav-item"><a href="/docs/" class="nav-link">
  微代码
</a></div><div class="nav-item"><a href="/tag/" class="nav-link">
  云标签
</a></div> <!----></nav>  <ul class="sidebar-links"><li><div depth="0" class="sidebar-group"><p class="sidebar-heading open"><span>拖拽排序</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#前言" class="sidebar-link">前言</a></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#如何排序" class="sidebar-link">如何排序</a></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#相关事件" class="sidebar-link">相关事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#mouse-事件" class="sidebar-link">mouse 事件</a></li><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#drag-事件" class="sidebar-link">drag 事件</a></li><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#touch-事件" class="sidebar-link">touch 事件</a></li></ul></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#动画" class="sidebar-link">动画</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#动画完插入节点" class="sidebar-link">动画完插入节点</a></li><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#插入节点后动画" class="sidebar-link">插入节点后动画</a></li></ul></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#拖拽时滚动" class="sidebar-link">拖拽时滚动</a></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#列表组合" class="sidebar-link">列表组合</a></li></ul></div></li></ul> </div> <div class="page"> <div class="article-list-inner" style="display:none;"><div class="tag-container"><div class="tag-item-container" style="display:none;"><span class="tag">
        eslint
      </span><span class="tag">
        工具使用
      </span><span class="tag">
        VuePress
      </span><span class="tag">
        babel
      </span><span class="tag">
        总结
      </span><span class="tag">
        jsdoc
      </span><span class="tag">
        环境搭建
      </span><span class="tag">
        rollup
      </span><span class="tag">
        收藏
      </span><span class="tag">
        html
      </span><span class="tag">
        图片下载
      </span><span class="tag">
        canvas
      </span><span class="tag">
        布局
      </span><span class="tag">
        js
      </span><span class="tag">
        模块
      </span><span class="tag">
        vue
      </span><span class="tag">
        echart
      </span><span class="tag">
        moment
      </span><span class="tag">
        拖拽
      </span><span class="tag">
        css
      </span><span class="tag">
        组件
      </span><span class="tag">
        文档
      </span><span class="tag">
        websocket
      </span><span class="tag">
        socket.io
      </span><span class="tag">
        移动端
      </span></div> <div class="tag-tip" style="display:none;">
      标签为
      <span></span>下的文章
    </div></div> <div></div></div> <div class="content__default"><h1 id="拖拽排序"><a href="#拖拽排序" class="header-anchor">#</a> 拖拽排序</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>在做一个移动端项目时，有用到拖拽列表元素，为列表排序的地方。在其中也遇到了很多问题，和学到了很多新知识点，在这里做一个总结。</p> <p>本文将从事件，排序方法，动画方法，性能，列表联动等几个方面一一描述。</p> <h2 id="如何排序"><a href="#如何排序" class="header-anchor">#</a> 如何排序</h2> <p>所以我们需要知道整个列表所有可排序元素的位置信息，然后用 <code>A 节点的初始位置</code> + <code>鼠标移动的距离</code> 与这些位置一一比较，来获取到节点 B 以插入到节点 B 的前或后。</p> <p>假设当 A 节点的初始索引 <code>initIndex</code> 和 B 节点的索引 <code>hintIndex</code>：</p> <ol><li>当 <code>hintIndex</code> &gt; <code>initIndex</code> 时，插入到 B 节点后；</li> <li><code>hintIndex</code> &lt; <code>initIndex</code> 时，插入到 B 节点前。</li></ol> <p>拖动一个节点 A，当它中心点处于另一个节点中 B 时，A 节点插入到 B 节点的前或后。
<img src="https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/1592305958471.png" alt="enter description here"></p> <p>插入函数:</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token function">insertNode</span> <span class="token punctuation">(</span><span class="token parameter">newNode<span class="token punctuation">,</span> refNode<span class="token punctuation">,</span> before <span class="token operator">=</span> <span class="token boolean">true</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> parentNode <span class="token operator">=</span> refNode<span class="token punctuation">.</span>parentNode

    <span class="token keyword">if</span> <span class="token punctuation">(</span>before<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> tempNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>

      parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
      parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span>
      parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> refNode<span class="token punctuation">)</span>
      parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>refNode<span class="token punctuation">,</span> tempNode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>如果还需要对每个节点对应的数据进行排序，无论是插入到对应节点前或者后，那么 A 节点的新索引都会变成<code>hintIndex</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token function">sortData</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data <span class="token operator">||</span> <span class="token operator">!</span>data<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> dragItem <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    <span class="token comment">// 如果 end &gt; start，删除后，end 代表的元素已经代表原先的下一个</span>
    <span class="token comment">// end 前面添加</span>
    data<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> dragItem<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><h2 id="相关事件"><a href="#相关事件" class="header-anchor">#</a> 相关事件</h2> <p>我们需要在移动中，不断去循环遍历比较元素的位置。</p> <p>在移动端使用的是触摸（touch）的相关事件。</p> <p>在 pc 端使用的是拖拽（drag）或者鼠标（mouse）事件。</p> <p>整个 <code>排序流程</code> 如下：</p> <ol><li>在鼠标或手指按下时，生成拖拽节点 <code>dragNode</code> 的副本（<code>copy</code>）</li> <li>移动时，<code>copy</code> 跟着移动</li> <li>到达目标节点 <code>hintNode</code> 时，<code>dragNode</code> 插入的 <code>hintNode</code> 前后</li> <li>鼠标或手指松开时，移除 <code>copy</code></li></ol> <h3 id="mouse-事件"><a href="#mouse-事件" class="header-anchor">#</a> mouse 事件</h3> <h4 id="移出容器事件不响应"><a href="#移出容器事件不响应" class="header-anchor">#</a> 移出容器事件不响应</h4> <p>对于 <code>mouse</code> 事件，如果是对列表容器监听，那么在鼠标移出容器后，会不响应 <code>mousemove</code> 和 <code>mouseup</code> 事件。</p> <p>所以需要对整个 <code>body</code> 进行监听 <code>mouse</code> 事件。</p> <p>但是，在鼠标移出浏览器后，<code>mouseup</code>依然不会响应。这样，当我们在浏览器外松开鼠标时，并不会移除<code>copy</code>对象。</p> <p><strong>解决方法：</strong></p> <p>在鼠标离开浏览器时，会触发 <code>mouseleave</code> 事件，监听 mouseleave 事件，当是拖拽元素离开浏览器时，记录。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">mouseLeave</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 只有存在copy元素才记录</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nodeCopy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isMouseLeft <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>如果鼠标离开浏览器且在浏览器外松开鼠标，那么在下一次鼠标点击时，<code>remove</code> 掉上一次的 <code>copy</code> 元素。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">mouseDown</span> <span class="token operator">=</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>button <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>isMouseLeft<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>nodeCopy<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>nodeCopy <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// do other</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>同时在 <code>mouseup</code> 中 重设置 <code>isMouseLeft</code>，也就是如果 <code>mouseup</code> 没有丢失，那便不会触发 <code>mousedown</code> 中的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">mouseUp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>nodeCopy<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>nodeCopy <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 即使mouseup触发  mousemove还是会触发</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>isMouseLeft <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/1592357739080.jpg" alt="drag-out-window"></p> <p>当然这里的特殊性，可以直接在 <code>mousedown</code> 判断 <code>nodeCopy</code> 存在后删除：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">mouseDown</span> <span class="token operator">=</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>button <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nodeCopy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>nodeCopy<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>nodeCopy <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// do other</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>最后需要知道的是，与 <code>touch</code>、<code>drag</code> 事件不同的是：<code>mousemove</code> 是只需要鼠标在容器中移动就会触发，与是否 <code>mousedown</code> 或者 <code>mouseup</code> 无关。</p> <hr> <blockquote><p>2020-06-20 更新</p></blockquote> <p>这里只需要对 <code>window</code> 监听鼠标事件即可，这样即使离开浏览器，也会正常触发<code>mouseUp</code> 事件。</p> <h3 id="drag-事件"><a href="#drag-事件" class="header-anchor">#</a> drag 事件</h3> <h4 id="移动时鼠标坐标问题"><a href="#移动时鼠标坐标问题" class="header-anchor">#</a> 移动时鼠标坐标问题</h4> <p>对于 <code>drag</code> 事件，有一个问题，在 <code>drag</code> 事件中，鼠标的位置 <code>e.clientX</code>、<code>e.clientY</code> 会在开始的几次移动后突然变为 0 一次，同时在最后释放鼠标时也会为 0。</p> <p><img src="https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/1592305958473.png" alt=""></p> <p>这并不会影响排序，在变成 0 的那一瞬间，那意味着计算出来的拖拽元素坐标是 <code>0,0</code>。</p> <p>但如果需要在这里用到鼠标位置，例如：容器内可以滚动时，当拖拽元素到容器的可视边界时，容器自动向相应方向滚动。需要小心使用。</p> <h3 id="touch-事件"><a href="#touch-事件" class="header-anchor">#</a> touch 事件</h3> <h4 id="touch-和-滚动冲突"><a href="#touch-和-滚动冲突" class="header-anchor">#</a> touch 和 滚动冲突</h4> <p>在移动端，touch 事件会和浏览器滚动冲突，当使用 touch 移动节点时，会让页面也随之滚动。解决方法是在 <code>touchstart</code> 事件中添加 <code>preventDefault</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">touchStart</span> <span class="token operator">=</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>但在高版本浏览器中，会自动将 touch 事件的 <code>passive</code> 属性设置为 <code>true</code>，此时 <code>preventDefault</code> 会失效。</p> <p>所以需要判断是否支持 <code>passive</code>，支持时，添加事件时设置 <code>passive</code> 等于 <code>false</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setSupportsPassive</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> opts <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'passive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>supportsPassive <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'testPassive'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> opts<span class="token punctuation">)</span>
    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'testPassive'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> opts<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">_on</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
    event<span class="token punctuation">,</span>
    fn<span class="token punctuation">,</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>supportsPassive
      <span class="token operator">?</span> <span class="token punctuation">{</span>
        capture<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        passive<span class="token operator">:</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token operator">:</span> <span class="token boolean">false</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外还可以使用 css 属性 <code>touch-action</code>：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">#container</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 当触控事件发生在元素上时，不进行任何操作。 */</span>
  <span class="token property">touch-action</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在列表容器上使用，可以忽略浏览器默认的滚动行为。</p> <p>更多使用见：</p> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action" target="_blank" rel="noopener noreferrer">MDN touch-action<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="动画"><a href="#动画" class="header-anchor">#</a> 动画</h2> <p>对于动画的表现，肯定是过渡 <code>transform</code> 属性。</p> <h3 id="动画完插入节点"><a href="#动画完插入节点" class="header-anchor">#</a> 动画完插入节点</h3> <h4 id="单行"><a href="#单行" class="header-anchor">#</a> 单行</h4> <p>首先想到的肯定是，先执行动画，动画结束后再改变节点位置。</p> <p>这种情况下，需要去计算受影响节点的移动位置。</p> <p><img src="https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/1592305958474.png" alt="enter description here"></p> <p>A 节点插入到 E 节点后面，那 A 到 E 之间的节点（包括 E），都是需要向上移动 A 节点（包括 margin）所占据空间。</p> <p>同时 A 节点移动的距离是： <code>A.bottom 到 E.bottm 之间距离</code> + <code>E 的 marigin-bottom</code>。</p> <p>如果容器形成 BFC，那相邻块级元素的 <code>margin</code> 将会重叠，这种情况下难以去计算各个元素的 <code>margin</code>。</p> <p>所以只能限定元素的 <code>margin</code> 相等，这样就只需要根据位置信息去计算动画的距离。</p> <p><img src="https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/1592305958475.png" alt="enter description here"></p> <p>此时，A 到 E 之间的节点（包括 E）需要移动的距离是 <code>A.top - B.top</code>；A 节点需要移动的距离是<code>E.bottom - A.bottom</code>。</p> <p>这样即使元素大小不一，但只要 <code>margin</code> 一致，都可以正确动画。</p> <h4 id="多行"><a href="#多行" class="header-anchor">#</a> 多行</h4> <p>多行情况下，如果跨行排序，那每一行的的开头元素需要移动到上一行的末尾，同时这一行的其他元素，需要以这一行的第一个元素为基准移动。</p> <p><img src="https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/1592305958475.png" alt="enter description here"></p> <p>例如：F、G 移动的距离为 <code>F.left - E.left</code>。E 移动的距离为 <code>D.left - E.left ; D.top - E.top</code>。C 、D 移动的距离为 <code>B.left - C.left</code>。</p> <p>同样，多行拖拽排序也要求元素的 <code>margin</code> 相同，且元素大小也需要相同。</p> <h4 id="性能"><a href="#性能" class="header-anchor">#</a> 性能</h4> <p>元素的坐标可以用 <code>getBoundingClientRect</code> 获取。</p> <p>受影响的节点只与开始和结尾元素有关。</p> <p>不需要在每次移动都去获取坐标，可以在最开始存储所有节点坐标。当一次排序完成 —— <strong>鼠标手指松开，且动画结束后</strong>，对所有受影响的节点重新获取元素位置。</p> <p>这样在移动时，就只需要进行比较元素位置，和添加一个过渡动画。有很好的性能。</p> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <p>综上来看，<strong>先动画再插入节点</strong>有良好的性能，但也有许多限制：</p> <ol><li>margin 必须相同。</li> <li>多行情况下，元素大小也必须相同。</li></ol> <p>原因在于：无法准确的知道在插入节点后各个元素的新位置。</p> <h3 id="插入节点后动画"><a href="#插入节点后动画" class="header-anchor">#</a> 插入节点后动画</h3> <h4 id="根据坐标差动画"><a href="#根据坐标差动画" class="header-anchor">#</a> 根据坐标差动画</h4> <p>插入前获取各个节点的位置信息，插入后再获取各个节点的位置信息，根据两次位置的不同，来进行动画。这样可以完美解决上面动画完再插入节点的弊端。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">getPosition</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 相对于文档的位置</span>
  <span class="token keyword">const</span> scrollX <span class="token operator">=</span> window<span class="token punctuation">.</span>scrollX<span class="token punctuation">;</span>
  <span class="token keyword">const</span> scrollY <span class="token operator">=</span> window<span class="token punctuation">.</span>scrollY<span class="token punctuation">;</span>
  <span class="token keyword">const</span> cRect <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> left <span class="token operator">=</span> cRect<span class="token punctuation">.</span>left <span class="token operator">+</span> scrollX<span class="token punctuation">;</span>
  <span class="token keyword">const</span> top <span class="token operator">=</span> cRect<span class="token punctuation">.</span>top <span class="token operator">+</span> scrollY<span class="token punctuation">;</span>
  <span class="token keyword">const</span> right <span class="token operator">=</span> cRect<span class="token punctuation">.</span>right <span class="token operator">+</span> scrollX<span class="token punctuation">;</span>
  <span class="token keyword">const</span> bottom <span class="token operator">=</span> cRect<span class="token punctuation">.</span>bottom <span class="token operator">+</span> scrollY<span class="token punctuation">;</span>
  <span class="token keyword">const</span> width <span class="token operator">=</span> cRect<span class="token punctuation">.</span>right <span class="token operator">-</span> cRect<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token keyword">const</span> height <span class="token operator">=</span> cRect<span class="token punctuation">.</span>bottom <span class="token operator">-</span> cRect<span class="token punctuation">.</span>top<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    left<span class="token punctuation">,</span>
    right<span class="token punctuation">,</span>
    bottom<span class="token punctuation">,</span>
    top<span class="token punctuation">,</span>
    centreX<span class="token operator">:</span> left <span class="token operator">+</span> width <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>
    centreY<span class="token operator">:</span> top <span class="token operator">+</span> height <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>
    width<span class="token punctuation">,</span>
    height
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">style</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> styles</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>style<span class="token punctuation">,</span> styles<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">animate</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> positionBefore</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> transition <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">transform 300ms ease 0ms</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

  <span class="token comment">// 节点可能本身就在过渡，需要先取消过渡才能正确获取插入后各节点本身的位置信息</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    transition<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
    transform<span class="token operator">:</span> <span class="token string">&quot;&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 获取位置信息，getBoundingClientRect会强制引起重绘，所以能正确获取</span>
  <span class="token keyword">const</span> positionNow <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPosition</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    positionBefore<span class="token punctuation">.</span>left <span class="token operator">!==</span> positionNow<span class="token punctuation">.</span>left <span class="token operator">||</span>
    positionBefore<span class="token punctuation">.</span>top <span class="token operator">!==</span> positionNow<span class="token punctuation">.</span>top
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      transform<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">translate(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>positionBefore<span class="token punctuation">.</span>left <span class="token operator">-</span>
        positionNow<span class="token punctuation">.</span>left<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>positionBefore<span class="token punctuation">.</span>top <span class="token operator">-</span> positionNow<span class="token punctuation">.</span>top<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px)</span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        transform<span class="token operator">:</span> <span class="token string">&quot;translate(0, 0)&quot;</span><span class="token punctuation">,</span>
        transition<span class="token operator">:</span> transition
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 节点每次插入新位置后执行</span>
  <span class="token comment">// nodes 排序节点集合</span>
  <span class="token comment">// positionsBefore插入前的各节点位置信息</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>positionsBefore<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面 <code>animate</code> 函数可以分为以下几个步骤：</p> <ol><li>取消节点上一次的过渡状态，因为可能在上一次过渡还未完成，就插入到新位置。</li> <li>获取节点新的位置信息。</li> <li>新位置与旧位置进行比较，设置节点的过渡初始位置。</li> <li>下一帧开始过渡动画。</li></ol> <h4 id="下一帧"><a href="#下一帧" class="header-anchor">#</a> 下一帧</h4> <p>我们知道过渡产生的条件在于过渡属性的变化，也就是 <code>transform</code> 值的变化，且后面的变化必须等前面的变化已经渲染，才会产生过渡。</p> <p>浏览器的渲染机制：</p> <p>宏任务 -&gt; 微任务 -&gt; requestAnimationFrame -&gt; 重绘</p> <p>也就是说我们在下一个宏任务中设置过渡，就可以保证过渡的产生：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    transform<span class="token operator">:</span> <span class="token string">&quot;translate(0, 0)&quot;</span><span class="token punctuation">,</span>
    transition<span class="token operator">:</span> transition
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但使用 <code>setTimeout</code> 并不能保证一定生效，因为在每次宏任务最后并不会一定重绘，只是重绘一定发生在当前宏任务的最后。</p> <p>重绘应该是以一个默认周期（浏览器屏幕刷新数）去重绘，比如 16.6ms， 所以在使用 setTimeout 时，如果 2 次宏任务恰好在同一周期，依然不会产生过渡。(经测试，使用 chrome 模拟的手机容易出现问题)</p> <p>使用 <code>requestAnimationFrame</code> 可以保证在重绘前执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    transform<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">translate(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>positionBefore<span class="token punctuation">.</span>left <span class="token operator">-</span>
      positionNow<span class="token punctuation">.</span>left<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>positionBefore<span class="token punctuation">.</span>top <span class="token operator">-</span> positionNow<span class="token punctuation">.</span>top<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px)</span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      transform<span class="token operator">:</span> <span class="token string">&quot;translate(0, 0)&quot;</span><span class="token punctuation">,</span>
      transition<span class="token operator">:</span> transition
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样可以确实可以保证过渡会在下一帧执行，但如果快速移动，会导致过于频繁的触发，这样两次的 <code>requestAnimationFrame</code> 会在同一重绘前执行，过渡还是会失效。(经测试，使用 chrome 模拟的手机容易出现问题)</p> <p>并且在 pc 端的 chrome 浏览器中，每一次插入节点都会出现闪烁。</p> <p>使用节流函数(<code>requestAnimationFrame</code>)，保证每次渲染前只执行一次 move 函数，这样 <code>setTimeout</code> 就一定会在下一帧执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> curTick <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">;</span>

  params<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> curParams <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>curTick<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      curTick <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>curParams<span class="token punctuation">,</span> params<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        curTick <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">throttle</span><span class="token punctuation">(</span>move<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="强制重绘"><a href="#强制重绘" class="header-anchor">#</a> 强制重绘</h4> <p>当然也可以不使用 <code>setTimeout</code>或是 <code>requestAnimationFrame</code> 让过渡在下一帧执行，从过渡产生的条件来看，只需要让前面的 <code>transform</code> 属性渲染了，然后再设置过渡即可。</p> <p>浏览器提供了一些方法来强制重绘，比如访问 <code>clientWidth</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  transform<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">translate(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>positionBefore<span class="token punctuation">.</span>left <span class="token operator">-</span>
    positionNow<span class="token punctuation">.</span>left<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>positionBefore<span class="token punctuation">.</span>top <span class="token operator">-</span> positionNow<span class="token punctuation">.</span>top<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px)</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 强制重绘</span>
el<span class="token punctuation">.</span>clientWidth<span class="token punctuation">;</span>

<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  transform<span class="token operator">:</span> <span class="token string">&quot;translate(0, 0)&quot;</span><span class="token punctuation">,</span>
  transition<span class="token operator">:</span> transition
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样也能正确产生过渡。但强制重绘的代价是昂贵的，再循环中对每一个更改的节点都使用强制重绘，会大大增加时间复杂度。</p> <h4 id="性能-2"><a href="#性能-2" class="header-anchor">#</a> 性能</h4> <p>看到这里，<strong>强制重绘是非常耗时的</strong>，而正好上面的 <code>getPosition</code> 方法中使用了 <code>getBoundingClientRect</code>，这也会强制重绘。</p> <p>浏览器会在合适的时候清空渲染队列，而强制重绘会立刻清空渲染队列，这也是强制重绘耗时的
原因。如果渲染队列为空，那么即使方法会引发强制重绘，也会节省很多时间。</p> <p>在上面的代码中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 节点可能本身就在过渡，需要先取消过渡才能正确获取插入后各节点本身的位置信息</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  transition<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
  transform<span class="token operator">:</span> <span class="token string">&quot;&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取位置信息，getBoundingClientRect会强制引起重绘，所以能正确获取</span>
<span class="token keyword">const</span> positionNow <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPosition</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在每次 <code>getPosition</code> 前都设置了元素的 style 属性，这会导致 <code>getPosition</code> 的非常耗时（因为需要清空渲染队列重绘）。</p> <p>而这里是可以让 <code>getPosition</code> 引发的重绘只触发一次的。只需要先将所有节点的上一次过渡取消，再对每个节点使用 <code>getPosition</code> 获得当前位置即可，这样只会在第一次 <code>getPosition</code> 时清空渲染队列重绘。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">el</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      transition<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
      transform<span class="token operator">:</span> <span class="token string">&quot;&quot;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> postionsNow <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPosition</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">animateDiffPos</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>positionsBefore<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> positionsNow<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">animateDiffPos</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> positionBefore<span class="token punctuation">,</span> positionNow</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> transition <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">transform 300ms ease 0ms</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    positionBefore<span class="token punctuation">.</span>left <span class="token operator">!==</span> positionNow<span class="token punctuation">.</span>left <span class="token operator">||</span>
    positionBefore<span class="token punctuation">.</span>top <span class="token operator">!==</span> positionNow<span class="token punctuation">.</span>top
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      transform<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">translate(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>positionBefore<span class="token punctuation">.</span>left <span class="token operator">-</span>
        positionNow<span class="token punctuation">.</span>left<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>positionBefore<span class="token punctuation">.</span>top <span class="token operator">-</span> positionNow<span class="token punctuation">.</span>top<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px)</span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        transform<span class="token operator">:</span> <span class="token string">&quot;translate(0, 0)&quot;</span><span class="token punctuation">,</span>
        transition<span class="token operator">:</span> transition
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/1592305958490.png" alt="enter description here"></p> <p>可以看到除了第一次耗时比较长之外，后面的耗时都比较少。</p> <p>虽然循环次数增加，但重绘只会发生在第一次调用 <code>getPosition</code> 。时间复杂度大约只是原先的一半。</p> <p>在一次移动中，需要两次获取全部节点的位置信息（插入节点前的和插入节点后的），而在两次获取全部节点位置信息时，会引发 2 次重绘。</p> <p>使用这种方法是可以完美做到适配各种情况的排序，但时间复杂度会是<code>动画完插入节点</code>的 5 倍。</p> <p>动画后再插入节点：</p> <p><img src="https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/1592877681348.png" alt="1592305958491"></p> <p>插入节点后再动画：</p> <p><img src="https://fireli-1256465711.cos.ap-chengdu.myqcloud.com/img/1592305958491.png" alt="enter description here"></p> <h4 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h4> <ol><li>只需使用 <code>getBoundingClientRect</code> 获取插入节点前后的坐标，根据坐标差进行动画。</li> <li>可以适用各种情况（例如元素大小、margin 等不同）。</li> <li>两次获取位置必然会引发 2 次重绘，<strong>重绘</strong> 和 <strong>多次调用 <code>getBoundingClientRect</code></strong> 耗时高，耗时约是上一种方法的 5 倍。</li> <li>用于低配置设备效果并不理想。</li></ol> <h2 id="拖拽时滚动"><a href="#拖拽时滚动" class="header-anchor">#</a> 拖拽时滚动</h2> <p>拖拽时滚动分为 2 种：</p> <ol><li>页面滚动</li> <li>列表容器内滚动</li></ol> <p>判断页面和一个节点是否能滚动的方法见：</p> <p><a href="/blog/web/元素大小、位置、滚动相关知识点.html#判断是否有滚动条">滚动产生的条件</a></p> <p>然后在每次移动时，根据<strong>触摸位置</strong>是否触碰到<strong>当前可视窗口边界</strong>或<strong>容器边界</strong>来控制滚动。获取坐标时，都选择为同一个参考系，例如文档左上角。</p> <h2 id="列表组合"><a href="#列表组合" class="header-anchor">#</a> 列表组合</h2> <p>一个拖拽排序列表的理想实现是一个类，传入一个<strong>容器节点</strong>，并将容器中的特定子节点设置为可排序。</p> <p>2 个排序列表表示是类的 2 个实例，如果要让一个列表中的元素能够拖拽到另一个列表中去，最好的方式是：不改变类中的排序逻辑，并提供完善的方法和事件，从实例本身去操控列表之间的拖拽。</p> <p>例如一个节点 <code>m</code> 从 <code>A</code> 列表拖拽到 <code>B</code> 列表的 <code>n</code> 节点后面，<code>m'</code> 为 <code>m</code> 元素的副本，跟随鼠标移动。</p> <ol><li><p>监听每一次 move 事件，如果 <code>m'</code> 进入 B 列表，且 <code>m'</code> 中心进入到 n 中</p></li> <li><p>将 <code>m</code> 以动画的形式添加到 <code>B</code> 列表中，同时动画 <code>B</code> 列表中其他位置受影响的节点。类提供相关方法来添加节点，并传入 <code>position</code> 参数来表示 <code>m</code> 节点之前的位置。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
* @description 从指定位置动画添加节点
* @param {Number} index 插入位置的索引
* @param {Object} newNode 插入的节点
* @param {Object} position 节点的初始位置
*/</span>

<span class="token function">addNodeAnimated</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> index<span class="token punctuation">,</span> newNode<span class="token punctuation">,</span> position <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前列表全部节点位置</span>
  <span class="token comment">// 插入节点newNode</span>
  <span class="token comment">// 获取newNode的新位置</span>
  <span class="token comment">// 获取列表原有节点的新位置</span>
  <span class="token comment">// 根据新旧位置动画这些节点</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>A</code> 列表中，由于移除了一个节点，位置受影响的元素以动画的表现：在 <code>m</code> 添加到 <code>B</code> 前后分别获取 <code>A</code> 中所有节点位置，根据新旧位置信息动画节点。</p></li> <li><p>将 <code>A</code> 中的一些信息，例如鼠标位置、拖拽的节点传入到 <code>B</code> 中。这样 <code>B</code> 也可以通过移动继续排序。</p></li></ol></div> <div class="sidebar-right"><div class="sidebar-right-inner"><div class="newest"><div class="title">
          推荐阅读
        </div> <ol class="title-list"></ol></div> <div class="about"><div class="title">
          云标签
        </div> <div class="title-list"><span class="tag">
            eslint
          </span><span class="tag">
            工具使用
          </span><span class="tag">
            VuePress
          </span><span class="tag">
            babel
          </span><span class="tag">
            总结
          </span><span class="tag">
            jsdoc
          </span><span class="tag">
            环境搭建
          </span><span class="tag">
            rollup
          </span><span class="tag">
            收藏
          </span><span class="tag">
            html
          </span><span class="tag">
            图片下载
          </span><span class="tag">
            canvas
          </span><span class="tag">
            布局
          </span><span class="tag">
            js
          </span><span class="tag">
            模块
          </span><span class="tag">
            vue
          </span><span class="tag">
            echart
          </span><span class="tag">
            moment
          </span><span class="tag">
            拖拽
          </span><span class="tag">
            css
          </span><span class="tag">
            组件
          </span><span class="tag">
            文档
          </span><span class="tag">
            websocket
          </span><span class="tag">
            socket.io
          </span><span class="tag">
            移动端
          </span></div></div> <div class="catalog"><div class="title">
          目录
        </div> <ul class="sidebar-links"><li><div depth="0" class="sidebar-group"><p class="sidebar-heading open"><span>拖拽排序</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#前言" class="sidebar-link">前言</a></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#如何排序" class="sidebar-link">如何排序</a></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#相关事件" class="sidebar-link">相关事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#mouse-事件" class="sidebar-link">mouse 事件</a></li><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#drag-事件" class="sidebar-link">drag 事件</a></li><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#touch-事件" class="sidebar-link">touch 事件</a></li></ul></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#动画" class="sidebar-link">动画</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#动画完插入节点" class="sidebar-link">动画完插入节点</a></li><li class="sidebar-sub-header"><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#插入节点后动画" class="sidebar-link">插入节点后动画</a></li></ul></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#拖拽时滚动" class="sidebar-link">拖拽时滚动</a></li><li><a href="/blog/web/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.html#列表组合" class="sidebar-link">列表组合</a></li></ul></div></li></ul></div></div></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/29/2020, 7:20:32 PM</span></div></div> <!----> </div> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.61190595.js" defer></script><script src="/assets/js/32.6e130523.js" defer></script>

    <div class="cm-enter-loading">
      <div class="cm-spinner-box">
        <div class="cm-configure-border-1">
          <div class="cm-configure-core"></div>
        </div>
        <div class="cm-configure-border-2">
          <div class="cm-configure-core"></div>
        </div>
        <p class="cm-loading-text">loading...</p>
      </div>
    </div>

    <style>
      .cm-enter-loading {
        position: fixed;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        background-color: #37474f;
        z-index: 10000;
      }

      .cm-spinner-box {
        display: inline-block;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
      }
      .cm-configure-border-1 {
        width: 115px;
        height: 115px;
        padding: 3px;
        position: absolute;
        background: #ffab91;
        animation: configure-clockwise 3s ease-in-out 0s infinite alternate;
      }

      .cm-configure-border-2 {
        width: 115px;
        height: 115px;
        padding: 3px;
        left: -115px;
        background: rgb(63, 249, 220);
        transform: rotate(45deg);
        animation: configure-xclockwise 3s ease-in-out 0s infinite alternate;
      }

      .cm-configure-core {
        width: 100%;
        height: 100%;
        background-color: #37474f;
      }

      .cm-loading-text {
        font-size: 40px;
        color: white;
        font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif
      }

      @keyframes configure-clockwise {
        0% {
          transform: rotate(0);
        }
        25% {
          transform: rotate(90deg);
        }
        50% {
          transform: rotate(180deg);
        }
        75% {
          transform: rotate(270deg);
        }
        100% {
          transform: rotate(359deg);
        }
      }

      @keyframes configure-xclockwise {
        0% {
          transform: rotate(45deg);
        }
        25% {
          transform: rotate(-45deg);
        }
        50% {
          transform: rotate(-135deg);
        }
        75% {
          transform: rotate(-215deg);
        }
        100% {
          transform: rotate(-305deg);
        }
      }
    </style>

  </body>
</html>